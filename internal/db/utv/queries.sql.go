// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package utvsqlc

import (
	"context"
	"encoding/json"
	"time"

	"database/sql"

	"github.com/google/uuid"
)

const addNotification = `-- name: AddNotification :one

INSERT INTO notifications(id, to_id, from_id, status, expires, notification)
VALUES(uuid_generate_v4(), $1, $2, $3, $4, $5)
RETURNING id
`

type AddNotificationParams struct {
	ToID         uuid.UUID
	FromID       uuid.UUID
	Status       int32
	Expires      int32
	Notification json.RawMessage
}

// notifications.py
func (q *Queries) AddNotification(ctx context.Context, arg AddNotificationParams) (uuid.UUID, error) {
	row := q.queryRow(ctx, q.addNotificationStmt, addNotification,
		arg.ToID,
		arg.FromID,
		arg.Status,
		arg.Expires,
		arg.Notification,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const addOrUpdateUser = `-- name: AddOrUpdateUser :exec
INSERT INTO user_data(user_id, data)
VALUES ($1, $2)
ON CONFLICT (user_id)
    DO UPDATE SET data = EXCLUDED.data
`

type AddOrUpdateUserParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
}

func (q *Queries) AddOrUpdateUser(ctx context.Context, arg AddOrUpdateUserParams) error {
	_, err := q.exec(ctx, q.addOrUpdateUserStmt, addOrUpdateUser, arg.UserID, arg.Data)
	return err
}

const addUser = `-- name: AddUser :exec


INSERT INTO user_data(user_id, data)
VALUES ($1, $2)
`

type AddUserParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
}

// Common sql queries
// user_db.py
func (q *Queries) AddUser(ctx context.Context, arg AddUserParams) error {
	_, err := q.exec(ctx, q.addUserStmt, addUser, arg.UserID, arg.Data)
	return err
}

const addUserToGroup = `-- name: AddUserToGroup :exec
INSERT INTO utv_group_members(group_id, user_id, added)
VALUES ($1, $2, $3)
`

type AddUserToGroupParams struct {
	GroupID uuid.NullUUID
	UserID  uuid.UUID
	Added   int32
}

func (q *Queries) AddUserToGroup(ctx context.Context, arg AddUserToGroupParams) error {
	_, err := q.exec(ctx, q.addUserToGroupStmt, addUserToGroup, arg.GroupID, arg.UserID, arg.Added)
	return err
}

const createGroup = `-- name: CreateGroup :exec
INSERT INTO utv_groups(id, group_name, created, active, deleted)
VALUES($1, $2, $3, $4, $5)
`

type CreateGroupParams struct {
	ID        uuid.UUID
	GroupName string
	Created   int32
	Active    int32
	Deleted   int32
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) error {
	_, err := q.exec(ctx, q.createGroupStmt, createGroup,
		arg.ID,
		arg.GroupName,
		arg.Created,
		arg.Active,
		arg.Deleted,
	)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM utv_groups
WHERE id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteGroupStmt, deleteGroup, id)
	return err
}

const deleteAllGarminData = `-- name: DeleteAllGarminData :execrows
DELETE FROM garmin_data WHERE user_id = $1
`

func (q *Queries) DeleteAllGarminData(ctx context.Context, userID uuid.UUID) (int64, error) {
	result, err := q.exec(ctx, q.deleteAllGarminDataStmt, deleteAllGarminData, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteAllOuraData = `-- name: DeleteAllOuraData :execrows
DELETE FROM oura_data WHERE user_id = $1
`

func (q *Queries) DeleteAllOuraData(ctx context.Context, userID uuid.UUID) (int64, error) {
	result, err := q.exec(ctx, q.deleteAllOuraDataStmt, deleteAllOuraData, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteAllPolarData = `-- name: DeleteAllPolarData :execrows
DELETE FROM polar_data WHERE user_id = $1
`

func (q *Queries) DeleteAllPolarData(ctx context.Context, userID uuid.UUID) (int64, error) {
	result, err := q.exec(ctx, q.deleteAllPolarDataStmt, deleteAllPolarData, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteAllSuuntoData = `-- name: DeleteAllSuuntoData :execrows
DELETE FROM suunto_data WHERE user_id = $1
`

func (q *Queries) DeleteAllSuuntoData(ctx context.Context, userID uuid.UUID) (int64, error) {
	result, err := q.exec(ctx, q.deleteAllSuuntoDataStmt, deleteAllSuuntoData, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM user_data
WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteUserStmt, deleteUser, userID)
	return err
}

const getAllDataForDateGarmin = `-- name: GetAllDataForDateGarmin :one
SELECT data
FROM garmin_data
WHERE user_id = $1
AND summary_date = $2
`

type GetAllDataForDateGarminParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetAllDataForDateGarmin(ctx context.Context, arg GetAllDataForDateGarminParams) (json.RawMessage, error) {
	row := q.queryRow(ctx, q.getAllDataForDateGarminStmt, getAllDataForDateGarmin, arg.UserID, arg.Date)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getAllDataForDateOura = `-- name: GetAllDataForDateOura :one
SELECT data
FROM oura_data
WHERE user_id = $1
AND summary_date = $2
`

type GetAllDataForDateOuraParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetAllDataForDateOura(ctx context.Context, arg GetAllDataForDateOuraParams) (json.RawMessage, error) {
	row := q.queryRow(ctx, q.getAllDataForDateOuraStmt, getAllDataForDateOura, arg.UserID, arg.Date)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getAllDataForDatePolar = `-- name: GetAllDataForDatePolar :one
SELECT data
FROM polar_data
WHERE user_id = $1
AND summary_date = $2
`

type GetAllDataForDatePolarParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetAllDataForDatePolar(ctx context.Context, arg GetAllDataForDatePolarParams) (json.RawMessage, error) {
	row := q.queryRow(ctx, q.getAllDataForDatePolarStmt, getAllDataForDatePolar, arg.UserID, arg.Date)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getAllDataForDateSuunto = `-- name: GetAllDataForDateSuunto :one
SELECT data
FROM suunto_data
WHERE user_id = $1
AND summary_date = $2
`

type GetAllDataForDateSuuntoParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetAllDataForDateSuunto(ctx context.Context, arg GetAllDataForDateSuuntoParams) (json.RawMessage, error) {
	row := q.queryRow(ctx, q.getAllDataForDateSuuntoStmt, getAllDataForDateSuunto, arg.UserID, arg.Date)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getAllDataTypes = `-- name: GetAllDataTypes :many

SELECT data
FROM source_cache
WHERE ($1 IS NULL OR source = $1)
`

// api_db.py
func (q *Queries) GetAllDataTypes(ctx context.Context, dollar_1 interface{}) ([]json.RawMessage, error) {
	rows, err := q.query(ctx, q.getAllDataTypesStmt, getAllDataTypes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var data json.RawMessage
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}
		items = append(items, data)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppData = `-- name: GetAppData :many
SELECT data
FROM app_data
WHERE app_id = $1
AND field_name = $2
`

type GetAppDataParams struct {
	AppID     string
	FieldName string
}

func (q *Queries) GetAppData(ctx context.Context, arg GetAppDataParams) ([]json.RawMessage, error) {
	rows, err := q.query(ctx, q.getAppDataStmt, getAppData, arg.AppID, arg.FieldName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var data json.RawMessage
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}
		items = append(items, data)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataPointFromCoachtechData = `-- name: GetDataPointFromCoachtechData :many
WITH cte AS (
    SELECT coachtech_id
    FROM coachtech_ids
    WHERE user_id = $1
)
SELECT data
FROM coachtech_data
WHERE summary_date=$2
AND coachtech_id = (SELECT coachtech_id FROM cte)
`

type GetDataPointFromCoachtechDataParams struct {
	UserID      uuid.UUID
	SummaryDate time.Time
}

func (q *Queries) GetDataPointFromCoachtechData(ctx context.Context, arg GetDataPointFromCoachtechDataParams) ([]json.RawMessage, error) {
	rows, err := q.query(ctx, q.getDataPointFromCoachtechDataStmt, getDataPointFromCoachtechData, arg.UserID, arg.SummaryDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var data json.RawMessage
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}
		items = append(items, data)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatesFromCoachtechData = `-- name: GetDatesFromCoachtechData :many


WITH cte AS (
    SELECT coachtech_id
    FROM coachtech_ids
    WHERE user_id = $1
)
SELECT DISTINCT summary_date
FROM (
    SELECT summary_date
    FROM coachtech_data
    WHERE coachtech_id = (SELECT coachtech_id FROM cte)
    AND
    summary_date BETWEEN $2 AND $3
    AND
    data ->> 'testType' LIKE $4
) AS acceptables
ORDER BY summary_date DESC
`

type GetDatesFromCoachtechDataParams struct {
	UserID        uuid.UUID
	SummaryDate   time.Time
	SummaryDate_2 time.Time
	Data          json.RawMessage
}

// Wearable related functions
// api_db.py
func (q *Queries) GetDatesFromCoachtechData(ctx context.Context, arg GetDatesFromCoachtechDataParams) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getDatesFromCoachtechDataStmt, getDatesFromCoachtechData,
		arg.UserID,
		arg.SummaryDate,
		arg.SummaryDate_2,
		arg.Data,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var summary_date time.Time
		if err := rows.Scan(&summary_date); err != nil {
			return nil, err
		}
		items = append(items, summary_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatesFromGarminData = `-- name: GetDatesFromGarminData :many
SELECT DISTINCT summary_date
FROM garmin_data
WHERE user_id = $1
AND ($2::date IS NULL OR summary_date >= $2)
AND ($3::date IS NULL OR summary_date <= $3)
ORDER BY summary_date DESC
`

type GetDatesFromGarminDataParams struct {
	UserID     uuid.UUID
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

func (q *Queries) GetDatesFromGarminData(ctx context.Context, arg GetDatesFromGarminDataParams) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getDatesFromGarminDataStmt, getDatesFromGarminData, arg.UserID, arg.AfterDate, arg.BeforeDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var summary_date time.Time
		if err := rows.Scan(&summary_date); err != nil {
			return nil, err
		}
		items = append(items, summary_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatesFromOuraData = `-- name: GetDatesFromOuraData :many
SELECT DISTINCT summary_date
FROM oura_data
WHERE user_id = $1
AND ($2::date IS NULL OR summary_date >= $2)
AND ($3::date IS NULL OR summary_date <= $3)
ORDER BY summary_date DESC
`

type GetDatesFromOuraDataParams struct {
	UserID     uuid.UUID
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

func (q *Queries) GetDatesFromOuraData(ctx context.Context, arg GetDatesFromOuraDataParams) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getDatesFromOuraDataStmt, getDatesFromOuraData, arg.UserID, arg.AfterDate, arg.BeforeDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var summary_date time.Time
		if err := rows.Scan(&summary_date); err != nil {
			return nil, err
		}
		items = append(items, summary_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatesFromPolarData = `-- name: GetDatesFromPolarData :many
SELECT DISTINCT summary_date
FROM polar_data
WHERE user_id = $1
AND ($2::date IS NULL OR summary_date >= $2)
AND ($3::date IS NULL OR summary_date <= $3)
ORDER BY summary_date DESC
`

type GetDatesFromPolarDataParams struct {
	UserID     uuid.UUID
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

func (q *Queries) GetDatesFromPolarData(ctx context.Context, arg GetDatesFromPolarDataParams) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getDatesFromPolarDataStmt, getDatesFromPolarData, arg.UserID, arg.AfterDate, arg.BeforeDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var summary_date time.Time
		if err := rows.Scan(&summary_date); err != nil {
			return nil, err
		}
		items = append(items, summary_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatesFromSuuntoData = `-- name: GetDatesFromSuuntoData :many
SELECT DISTINCT summary_date
FROM suunto_data
WHERE user_id = $1
AND ($2::date IS NULL OR summary_date >= $2)
AND ($3::date IS NULL OR summary_date <= $3)
ORDER BY summary_date DESC
`

type GetDatesFromSuuntoDataParams struct {
	UserID     uuid.UUID
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

func (q *Queries) GetDatesFromSuuntoData(ctx context.Context, arg GetDatesFromSuuntoDataParams) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getDatesFromSuuntoDataStmt, getDatesFromSuuntoData, arg.UserID, arg.AfterDate, arg.BeforeDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var summary_date time.Time
		if err := rows.Scan(&summary_date); err != nil {
			return nil, err
		}
		items = append(items, summary_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotification = `-- name: GetNotification :one
SELECT id, to_id, from_id, status, expires, notification
FROM notifications
WHERE id = $2 AND ($1 IS NULL OR expires >= $1)
`

type GetNotificationParams struct {
	Column1 interface{}
	ID      uuid.UUID
}

func (q *Queries) GetNotification(ctx context.Context, arg GetNotificationParams) (Notification, error) {
	row := q.queryRow(ctx, q.getNotificationStmt, getNotification, arg.Column1, arg.ID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.ToID,
		&i.FromID,
		&i.Status,
		&i.Expires,
		&i.Notification,
	)
	return i, err
}

const getResourceMetadata = `-- name: GetResourceMetadata :many
SELECT data
FROM resource_data
WHERE resource_id = $1
`

func (q *Queries) GetResourceMetadata(ctx context.Context, resourceID string) ([]json.RawMessage, error) {
	rows, err := q.query(ctx, q.getResourceMetadataStmt, getResourceMetadata, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var data json.RawMessage
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}
		items = append(items, data)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecificDataForDateGarmin = `-- name: GetSpecificDataForDateGarmin :one
SELECT data->$3::text
FROM garmin_data
WHERE user_id = $1
AND summary_date = $2
`

type GetSpecificDataForDateGarminParams struct {
	UserID uuid.UUID
	Date   time.Time
	Key    *string
}

func (q *Queries) GetSpecificDataForDateGarmin(ctx context.Context, arg GetSpecificDataForDateGarminParams) (interface{}, error) {
	row := q.queryRow(ctx, q.getSpecificDataForDateGarminStmt, getSpecificDataForDateGarmin, arg.UserID, arg.Date, arg.Key)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getSpecificDataForDateOura = `-- name: GetSpecificDataForDateOura :one
SELECT data->$3::text
FROM oura_data
WHERE user_id = $1
AND summary_date = $2
`

type GetSpecificDataForDateOuraParams struct {
	UserID uuid.UUID
	Date   time.Time
	Key    *string
}

func (q *Queries) GetSpecificDataForDateOura(ctx context.Context, arg GetSpecificDataForDateOuraParams) (interface{}, error) {
	row := q.queryRow(ctx, q.getSpecificDataForDateOuraStmt, getSpecificDataForDateOura, arg.UserID, arg.Date, arg.Key)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getSpecificDataForDatePolar = `-- name: GetSpecificDataForDatePolar :one
SELECT data->$3::text
FROM polar_data
WHERE user_id = $1
AND summary_date = $2
`

type GetSpecificDataForDatePolarParams struct {
	UserID uuid.UUID
	Date   time.Time
	Key    *string
}

func (q *Queries) GetSpecificDataForDatePolar(ctx context.Context, arg GetSpecificDataForDatePolarParams) (interface{}, error) {
	row := q.queryRow(ctx, q.getSpecificDataForDatePolarStmt, getSpecificDataForDatePolar, arg.UserID, arg.Date, arg.Key)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getSpecificDataForDateSuunto = `-- name: GetSpecificDataForDateSuunto :one
SELECT data->$3::text
FROM suunto_data
WHERE user_id = $1
AND summary_date = $2
`

type GetSpecificDataForDateSuuntoParams struct {
	UserID uuid.UUID
	Date   time.Time
	Key    *string
}

func (q *Queries) GetSpecificDataForDateSuunto(ctx context.Context, arg GetSpecificDataForDateSuuntoParams) (interface{}, error) {
	row := q.queryRow(ctx, q.getSpecificDataForDateSuuntoStmt, getSpecificDataForDateSuunto, arg.UserID, arg.Date, arg.Key)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getTypesFromCoachtechData = `-- name: GetTypesFromCoachtechData :many
WITH cte AS (
    SELECT coachtech_id
    FROM coachtech_ids
    WHERE user_id = $1
)
SELECT DISTINCT data->>'testType', data->>'time', data->>'id'
FROM coachtech_data
WHERE summary_date = $2
  AND coachtech_id = (SELECT coachtech_id FROM cte)
  AND (
      ($3 IS NULL AND data->>'testType' IS NOT NULL) OR
      (data->>'testType' = $3)
  )
`

type GetTypesFromCoachtechDataParams struct {
	UserID      uuid.UUID
	SummaryDate time.Time
	Column3     interface{}
}

type GetTypesFromCoachtechDataRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
}

func (q *Queries) GetTypesFromCoachtechData(ctx context.Context, arg GetTypesFromCoachtechDataParams) ([]GetTypesFromCoachtechDataRow, error) {
	rows, err := q.query(ctx, q.getTypesFromCoachtechDataStmt, getTypesFromCoachtechData, arg.UserID, arg.SummaryDate, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTypesFromCoachtechDataRow
	for rows.Next() {
		var i GetTypesFromCoachtechDataRow
		if err := rows.Scan(&i.Column1, &i.Column2, &i.Column3); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesFromGarminData = `-- name: GetTypesFromGarminData :many
SELECT DISTINCT jsonb_object_keys(data)
FROM garmin_data
WHERE user_id = $1
AND summary_date = $2
`

type GetTypesFromGarminDataParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetTypesFromGarminData(ctx context.Context, arg GetTypesFromGarminDataParams) ([]string, error) {
	rows, err := q.query(ctx, q.getTypesFromGarminDataStmt, getTypesFromGarminData, arg.UserID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var jsonb_object_keys string
		if err := rows.Scan(&jsonb_object_keys); err != nil {
			return nil, err
		}
		items = append(items, jsonb_object_keys)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesFromOuraData = `-- name: GetTypesFromOuraData :many
SELECT DISTINCT jsonb_object_keys(data)
FROM oura_data
WHERE user_id = $1
AND summary_date = $2
`

type GetTypesFromOuraDataParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetTypesFromOuraData(ctx context.Context, arg GetTypesFromOuraDataParams) ([]string, error) {
	rows, err := q.query(ctx, q.getTypesFromOuraDataStmt, getTypesFromOuraData, arg.UserID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var jsonb_object_keys string
		if err := rows.Scan(&jsonb_object_keys); err != nil {
			return nil, err
		}
		items = append(items, jsonb_object_keys)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesFromPolarData = `-- name: GetTypesFromPolarData :many
SELECT DISTINCT jsonb_object_keys(data)
FROM polar_data
WHERE user_id = $1
AND summary_date = $2
`

type GetTypesFromPolarDataParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetTypesFromPolarData(ctx context.Context, arg GetTypesFromPolarDataParams) ([]string, error) {
	rows, err := q.query(ctx, q.getTypesFromPolarDataStmt, getTypesFromPolarData, arg.UserID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var jsonb_object_keys string
		if err := rows.Scan(&jsonb_object_keys); err != nil {
			return nil, err
		}
		items = append(items, jsonb_object_keys)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesFromSuuntoData = `-- name: GetTypesFromSuuntoData :many
SELECT DISTINCT jsonb_object_keys(data)
FROM suunto_data
WHERE user_id = $1
AND summary_date = $2
`

type GetTypesFromSuuntoDataParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetTypesFromSuuntoData(ctx context.Context, arg GetTypesFromSuuntoDataParams) ([]string, error) {
	rows, err := q.query(ctx, q.getTypesFromSuuntoDataStmt, getTypesFromSuuntoData, arg.UserID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var jsonb_object_keys string
		if err := rows.Scan(&jsonb_object_keys); err != nil {
			return nil, err
		}
		items = append(items, jsonb_object_keys)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniqueCoachtechDataTypes = `-- name: GetUniqueCoachtechDataTypes :many
WITH cte AS (
    SELECT coachtech_id
    FROM coachtech_ids
    WHERE user_id = $1
)
SELECT DISTINCT data->>'testType'
FROM coachtech_data
WHERE coachtech_id = (SELECT coachtech_id FROM cte)
AND summary_date BETWEEN to_timestamp($2)::date AND to_timestamp($3)::date
`

type GetUniqueCoachtechDataTypesParams struct {
	UserID        uuid.UUID
	ToTimestamp   float64
	ToTimestamp_2 float64
}

func (q *Queries) GetUniqueCoachtechDataTypes(ctx context.Context, arg GetUniqueCoachtechDataTypesParams) ([]interface{}, error) {
	rows, err := q.query(ctx, q.getUniqueCoachtechDataTypesStmt, getUniqueCoachtechDataTypes, arg.UserID, arg.ToTimestamp, arg.ToTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var column_1 interface{}
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGarminData = `-- name: InsertGarminData :exec
INSERT INTO garmin_data (user_id, summary_date, data)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, summary_date)
DO UPDATE SET data = EXCLUDED.data
`

type InsertGarminDataParams struct {
	UserID uuid.UUID
	Date   time.Time
	Data   json.RawMessage
}

func (q *Queries) InsertGarminData(ctx context.Context, arg InsertGarminDataParams) error {
	_, err := q.exec(ctx, q.insertGarminDataStmt, insertGarminData, arg.UserID, arg.Date, arg.Data)
	return err
}

const insertOuraData = `-- name: InsertOuraData :exec
INSERT INTO oura_data (user_id, summary_date, data)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, summary_date)
DO UPDATE SET data = EXCLUDED.data
`

type InsertOuraDataParams struct {
	UserID uuid.UUID
	Date   time.Time
	Data   json.RawMessage
}

func (q *Queries) InsertOuraData(ctx context.Context, arg InsertOuraDataParams) error {
	_, err := q.exec(ctx, q.insertOuraDataStmt, insertOuraData, arg.UserID, arg.Date, arg.Data)
	return err
}

const insertPolarData = `-- name: InsertPolarData :exec
INSERT INTO polar_data (user_id, summary_date, data)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, summary_date)
DO UPDATE SET data = EXCLUDED.data
`

type InsertPolarDataParams struct {
	UserID uuid.UUID
	Date   time.Time
	Data   json.RawMessage
}

func (q *Queries) InsertPolarData(ctx context.Context, arg InsertPolarDataParams) error {
	_, err := q.exec(ctx, q.insertPolarDataStmt, insertPolarData, arg.UserID, arg.Date, arg.Data)
	return err
}

const insertSuuntoData = `-- name: InsertSuuntoData :exec
INSERT INTO suunto_data (user_id, summary_date, data)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, summary_date)
DO UPDATE SET data = EXCLUDED.data
`

type InsertSuuntoDataParams struct {
	UserID uuid.UUID
	Date   time.Time
	Data   json.RawMessage
}

func (q *Queries) InsertSuuntoData(ctx context.Context, arg InsertSuuntoDataParams) error {
	_, err := q.exec(ctx, q.insertSuuntoDataStmt, insertSuuntoData, arg.UserID, arg.Date, arg.Data)
	return err
}

const listGroupMembers = `-- name: ListGroupMembers :many
SELECT user_id, added
FROM utv_group_members
WHERE group_id = $1
`

type ListGroupMembersRow struct {
	UserID uuid.UUID
	Added  int32
}

func (q *Queries) ListGroupMembers(ctx context.Context, groupID uuid.NullUUID) ([]ListGroupMembersRow, error) {
	rows, err := q.query(ctx, q.listGroupMembersStmt, listGroupMembers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGroupMembersRow
	for rows.Next() {
		var i ListGroupMembersRow
		if err := rows.Scan(&i.UserID, &i.Added); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroups = `-- name: ListGroups :many
SELECT id, group_name, created, active, deleted FROM utv_groups
`

func (q *Queries) ListGroups(ctx context.Context) ([]UtvGroup, error) {
	rows, err := q.query(ctx, q.listGroupsStmt, listGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UtvGroup
	for rows.Next() {
		var i UtvGroup
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.Created,
			&i.Active,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsForUser = `-- name: ListGroupsForUser :many
SELECT utv_groups.id, utv_groups.group_name, utv_groups.created, utv_groups.active, utv_groups.deleted FROM utv_groups, utv_group_members
WHERE utv_groups.id = utv_group_members.group_id
    AND utv_group_members.user_id = $1
`

func (q *Queries) ListGroupsForUser(ctx context.Context, userID uuid.UUID) ([]UtvGroup, error) {
	rows, err := q.query(ctx, q.listGroupsForUserStmt, listGroupsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UtvGroup
	for rows.Next() {
		var i UtvGroup
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.Created,
			&i.Active,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, to_id, from_id, status, expires, notification
FROM notifications
WHERE
    ($1 IS NULL OR to_id = $1) AND
    ($2 IS NULL OR from_id = $2) AND
    ($3 IS NULL OR expires >= $3) AND
    ($4 IS NULL OR $4)
`

type ListNotificationsParams struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
}

func (q *Queries) ListNotifications(ctx context.Context, arg ListNotificationsParams) ([]Notification, error) {
	rows, err := q.query(ctx, q.listNotificationsStmt, listNotifications,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.ToID,
			&i.FromID,
			&i.Status,
			&i.Expires,
			&i.Notification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromGroup = `-- name: RemoveUserFromGroup :exec
DELETE from utv_group_members
WHERE user_id = $1 AND group_id = $2
`

type RemoveUserFromGroupParams struct {
	UserID  uuid.UUID
	GroupID uuid.NullUUID
}

func (q *Queries) RemoveUserFromGroup(ctx context.Context, arg RemoveUserFromGroupParams) error {
	_, err := q.exec(ctx, q.removeUserFromGroupStmt, removeUserFromGroup, arg.UserID, arg.GroupID)
	return err
}

const retrieveUser = `-- name: RetrieveUser :one
SELECT data
FROM user_data
WHERE user_id = $1
`

func (q *Queries) RetrieveUser(ctx context.Context, userID uuid.UUID) (json.RawMessage, error) {
	row := q.queryRow(ctx, q.retrieveUserStmt, retrieveUser, userID)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const setAppData = `-- name: SetAppData :exec
INSERT INTO app_data(app_id, field_name, data)
VALUES($1, $2, $3)
ON CONFLICT(app_id, field_name)
DO UPDATE SET data = EXCLUDED.data
`

type SetAppDataParams struct {
	AppID     string
	FieldName string
	Data      json.RawMessage
}

func (q *Queries) SetAppData(ctx context.Context, arg SetAppDataParams) error {
	_, err := q.exec(ctx, q.setAppDataStmt, setAppData, arg.AppID, arg.FieldName, arg.Data)
	return err
}

const setNotificationStatus = `-- name: SetNotificationStatus :one
UPDATE notifications
SET status = $1 
WHERE id = $2
RETURNING status
`

type SetNotificationStatusParams struct {
	Status int32
	ID     uuid.UUID
}

func (q *Queries) SetNotificationStatus(ctx context.Context, arg SetNotificationStatusParams) (int32, error) {
	row := q.queryRow(ctx, q.setNotificationStatusStmt, setNotificationStatus, arg.Status, arg.ID)
	var status int32
	err := row.Scan(&status)
	return status, err
}

const setPersonalInformation = `-- name: SetPersonalInformation :exec
INSERT INTO user_data(user_id, data)
VALUES($1, $2)
ON CONFLICT(user_id)
DO UPDATE SET DATA = $3
`

type SetPersonalInformationParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
	Data_2 json.RawMessage
}

func (q *Queries) SetPersonalInformation(ctx context.Context, arg SetPersonalInformationParams) error {
	_, err := q.exec(ctx, q.setPersonalInformationStmt, setPersonalInformation, arg.UserID, arg.Data, arg.Data_2)
	return err
}

const setResourceMetadata = `-- name: SetResourceMetadata :exec
INSERT INTO resource_data(resource_id, data)
VALUES($1, $2)
ON CONFLICT(resource_id)
DO UPDATE SET data = EXCLUDED.data
`

type SetResourceMetadataParams struct {
	ResourceID string
	Data       json.RawMessage
}

func (q *Queries) SetResourceMetadata(ctx context.Context, arg SetResourceMetadataParams) error {
	_, err := q.exec(ctx, q.setResourceMetadataStmt, setResourceMetadata, arg.ResourceID, arg.Data)
	return err
}

const toggleNotificationExpiration = `-- name: ToggleNotificationExpiration :one
UPDATE notifications
SET expires = -(SELECT expires FROM notifications WHERE notifications.id = $1)
WHERE notifications.id = $1
RETURNING expires
`

func (q *Queries) ToggleNotificationExpiration(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.queryRow(ctx, q.toggleNotificationExpirationStmt, toggleNotificationExpiration, id)
	var expires int32
	err := row.Scan(&expires)
	return expires, err
}

const getLatestGarminDataByType = `-- name: GetLatestGarminDataByType :many
SELECT summary_date, (data -> $2::text)::jsonb AS data
FROM garmin_data
WHERE user_id = $1 AND data ? $2
ORDER BY summary_date DESC
LIMIT $3
`

type GetLatestGarminDataByTypeParams struct {
	UserID uuid.UUID
	Type   string
	Limit  int32
}

type GetLatestGarminDataByTypeRow struct {
	SummaryDate time.Time
	Data        json.RawMessage
}

func (q *Queries) GetLatestGarminDataByType(ctx context.Context, arg GetLatestGarminDataByTypeParams) ([]GetLatestGarminDataByTypeRow, error) {
	rows, err := q.query(ctx, q.getLatestGarminDataByTypeStmt, getLatestGarminDataByType, arg.UserID, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestGarminDataByTypeRow
	for rows.Next() {
		var i GetLatestGarminDataByTypeRow
		if err := rows.Scan(&i.SummaryDate, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestOuraDataByType = `-- name: GetLatestOuraDataByType :many
SELECT summary_date, (data -> $2::text)::jsonb AS data
FROM oura_data
WHERE user_id = $1 AND data ? $2
ORDER BY summary_date DESC
LIMIT $3
`

type GetLatestOuraDataByTypeParams struct {
	UserID uuid.UUID
	Type   string
	Limit  int32
}

type GetLatestOuraDataByTypeRow struct {
	SummaryDate time.Time
	Data        json.RawMessage
}

func (q *Queries) GetLatestOuraDataByType(ctx context.Context, arg GetLatestOuraDataByTypeParams) ([]GetLatestOuraDataByTypeRow, error) {
	rows, err := q.query(ctx, q.getLatestOuraDataByTypeStmt, getLatestOuraDataByType, arg.UserID, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestOuraDataByTypeRow
	for rows.Next() {
		var i GetLatestOuraDataByTypeRow
		if err := rows.Scan(&i.SummaryDate, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPolarDataByType = `-- name: GetLatestPolarDataByType :many
SELECT summary_date, (data -> $2::text)::jsonb AS data
FROM polar_data
WHERE user_id = $1 AND data ? $2
ORDER BY summary_date DESC
LIMIT $3
`

type GetLatestPolarDataByTypeParams struct {
	UserID uuid.UUID
	Type   string
	Limit  int32
}

type GetLatestPolarDataByTypeRow struct {
	SummaryDate time.Time
	Data        json.RawMessage
}

func (q *Queries) GetLatestPolarDataByType(ctx context.Context, arg GetLatestPolarDataByTypeParams) ([]GetLatestPolarDataByTypeRow, error) {
	rows, err := q.query(ctx, q.getLatestPolarDataByTypeStmt, getLatestPolarDataByType, arg.UserID, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestPolarDataByTypeRow
	for rows.Next() {
		var i GetLatestPolarDataByTypeRow
		if err := rows.Scan(&i.SummaryDate, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestSuuntoDataByType = `-- name: GetLatestSuuntoDataByType :many
SELECT summary_date, (data -> $2::text)::jsonb AS data
FROM suunto_data
WHERE user_id = $1 AND data ? $2
ORDER BY summary_date DESC
LIMIT $3
`

type GetLatestSuuntoDataByTypeParams struct {
	UserID uuid.UUID
	Type   string
	Limit  int32
}

type GetLatestSuuntoDataByTypeRow struct {
	SummaryDate time.Time
	Data        json.RawMessage
}

func (q *Queries) GetLatestSuuntoDataByType(ctx context.Context, arg GetLatestSuuntoDataByTypeParams) ([]GetLatestSuuntoDataByTypeRow, error) {
	rows, err := q.query(ctx, q.getLatestSuuntoDataByTypeStmt, getLatestSuuntoDataByType, arg.UserID, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestSuuntoDataByTypeRow
	for rows.Next() {
		var i GetLatestSuuntoDataByTypeRow
		if err := rows.Scan(&i.SummaryDate, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataByTypeGarmin = `-- name: GetDataByTypeGarmin :many
SELECT summary_date, (data -> $2::text)::jsonb AS data
FROM garmin_data
WHERE user_id = $1
  AND data ? $2
  AND ($3::date IS NULL OR summary_date >= $3)
  AND ($4::date IS NULL OR summary_date <= $4)
ORDER BY summary_date DESC
`

type GetDataByTypeGarminParams struct {
	UserID     uuid.UUID
	Type       string
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

type GetDataByTypeGarminRow struct {
	SummaryDate time.Time
	Data        json.RawMessage
}

func (q *Queries) GetDataByTypeGarmin(ctx context.Context, arg GetDataByTypeGarminParams) ([]GetDataByTypeGarminRow, error) {
	rows, err := q.query(ctx, q.getDataByTypeGarminStmt, getDataByTypeGarmin,
		arg.UserID,
		arg.Type,
		arg.AfterDate,
		arg.BeforeDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDataByTypeGarminRow
	for rows.Next() {
		var i GetDataByTypeGarminRow
		if err := rows.Scan(&i.SummaryDate, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataByTypeOura = `-- name: GetDataByTypeOura :many
SELECT summary_date, (data -> $2::text)::jsonb AS data
FROM oura_data
WHERE user_id = $1
  AND data ? $2
  AND ($3::date IS NULL OR summary_date >= $3)
  AND ($4::date IS NULL OR summary_date <= $4)
ORDER BY summary_date DESC
`

type GetDataByTypeOuraParams struct {
	UserID     uuid.UUID
	Type       string
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

type GetDataByTypeOuraRow struct {
	SummaryDate time.Time
	Data        json.RawMessage
}

func (q *Queries) GetDataByTypeOura(ctx context.Context, arg GetDataByTypeOuraParams) ([]GetDataByTypeOuraRow, error) {
	rows, err := q.query(ctx, q.getDataByTypeOuraStmt, getDataByTypeOura,
		arg.UserID,
		arg.Type,
		arg.AfterDate,
		arg.BeforeDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDataByTypeOuraRow
	for rows.Next() {
		var i GetDataByTypeOuraRow
		if err := rows.Scan(&i.SummaryDate, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataByTypePolar = `-- name: GetDataByTypePolar :many
SELECT summary_date, (data -> $2::text)::jsonb AS data
FROM polar_data
WHERE user_id = $1
  AND data ? $2
  AND ($3::date IS NULL OR summary_date >= $3)
  AND ($4::date IS NULL OR summary_date <= $4)
ORDER BY summary_date DESC
`

type GetDataByTypePolarParams struct {
	UserID     uuid.UUID
	Type       string
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

type GetDataByTypePolarRow struct {
	SummaryDate time.Time
	Data        json.RawMessage
}

func (q *Queries) GetDataByTypePolar(ctx context.Context, arg GetDataByTypePolarParams) ([]GetDataByTypePolarRow, error) {
	rows, err := q.query(ctx, q.getDataByTypePolarStmt, getDataByTypePolar,
		arg.UserID,
		arg.Type,
		arg.AfterDate,
		arg.BeforeDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDataByTypePolarRow
	for rows.Next() {
		var i GetDataByTypePolarRow
		if err := rows.Scan(&i.SummaryDate, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataByTypeSuunto = `-- name: GetDataByTypeSuunto :many
SELECT summary_date, (data -> $2::text)::jsonb AS data
FROM suunto_data
WHERE user_id = $1
  AND data ? $2
  AND ($3::date IS NULL OR summary_date >= $3)
  AND ($4::date IS NULL OR summary_date <= $4)
ORDER BY summary_date DESC
`

type GetDataByTypeSuuntoParams struct {
	UserID     uuid.UUID
	Type       string
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

type GetDataByTypeSuuntoRow struct {
	SummaryDate time.Time
	Data        json.RawMessage
}

func (q *Queries) GetDataByTypeSuunto(ctx context.Context, arg GetDataByTypeSuuntoParams) ([]GetDataByTypeSuuntoRow, error) {
	rows, err := q.query(ctx, q.getDataByTypeSuuntoStmt, getDataByTypeSuunto,
		arg.UserID,
		arg.Type,
		arg.AfterDate,
		arg.BeforeDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDataByTypeSuuntoRow
	for rows.Next() {
		var i GetDataByTypeSuuntoRow
		if err := rows.Scan(&i.SummaryDate, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertGarminToken = `-- name: UpsertGarminToken :exec
INSERT INTO garmin_tokens (user_id, data)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE SET data = $2
`

type UpsertGarminTokenParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
}

func (q *Queries) UpsertGarminToken(ctx context.Context, arg UpsertGarminTokenParams) error {
	_, err := q.exec(ctx, q.upsertGarminTokenStmt, upsertGarminToken, arg.UserID, arg.Data)
	return err
}

const upsertOuraToken = `-- name: UpsertOuraToken :exec
INSERT INTO oura_tokens (user_id, data)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE SET data = $2
`

type UpsertOuraTokenParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
}

func (q *Queries) UpsertOuraToken(ctx context.Context, arg UpsertOuraTokenParams) error {
	_, err := q.exec(ctx, q.upsertOuraTokenStmt, upsertOuraToken, arg.UserID, arg.Data)
	return err
}

const upsertPolarToken = `-- name: UpsertPolarToken :exec
INSERT INTO polar_tokens (user_id, data)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE SET data = $2
`

type UpsertPolarTokenParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
}

func (q *Queries) UpsertPolarToken(ctx context.Context, arg UpsertPolarTokenParams) error {
	_, err := q.exec(ctx, q.upsertPolarTokenStmt, upsertPolarToken, arg.UserID, arg.Data)
	return err
}

const upsertSuuntoToken = `-- name: UpsertSuuntoToken :exec
INSERT INTO suunto_tokens (user_id, data)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE SET data = $2
`

type UpsertSuuntoTokenParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
}

func (q *Queries) UpsertSuuntoToken(ctx context.Context, arg UpsertSuuntoTokenParams) error {
	_, err := q.exec(ctx, q.upsertSuuntoTokenStmt, upsertSuuntoToken, arg.UserID, arg.Data)
	return err
}

const garminTokenExists = `-- name: GarminTokenExists :one
SELECT EXISTS(SELECT 1 FROM garmin_tokens WHERE data->>'access_token' = $1::text) AS exists
`

func (q *Queries) GarminTokenExists(ctx context.Context, dollar_1 string) (bool, error) {
	row := q.queryRow(ctx, q.garminTokenExistsStmt, garminTokenExists, dollar_1)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getGarminStatus = `-- name: GetGarminStatus :one
WITH input AS (
  SELECT $1::uuid AS uid
),
pt AS (
  SELECT EXISTS(SELECT 1 FROM garmin_tokens WHERE user_id = input.uid) AS connected FROM input
),
pd AS (
  SELECT EXISTS(SELECT 1 FROM garmin_data WHERE user_id = input.uid) AS data_exists FROM input
)
SELECT pt.connected, pd.data_exists FROM pt, pd
`

type GetGarminStatusRow struct {
	Connected  bool
	DataExists bool
}

func (q *Queries) GetGarminStatus(ctx context.Context, dollar_1 uuid.UUID) (GetGarminStatusRow, error) {
	row := q.queryRow(ctx, q.getGarminStatusStmt, getGarminStatus, dollar_1)
	var i GetGarminStatusRow
	err := row.Scan(&i.Connected, &i.DataExists)
	return i, err
}

const getGarminUserIDByToken = `-- name: GetGarminUserIDByToken :one
SELECT user_id
FROM garmin_tokens
WHERE data->>'access_token' = $1::text
`

func (q *Queries) GetGarminUserIDByToken(ctx context.Context, dollar_1 string) (uuid.UUID, error) {
	row := q.queryRow(ctx, q.getGarminUserIDByTokenStmt, getGarminUserIDByToken, dollar_1)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const getOuraStatus = `-- name: GetOuraStatus :one
WITH input AS (
  SELECT $1::uuid AS uid
),
pt AS (
  SELECT EXISTS(SELECT 1 FROM oura_tokens WHERE user_id = input.uid) AS connected FROM input
),
pd AS (
  SELECT EXISTS(SELECT 1 FROM oura_data WHERE user_id = input.uid) AS data_exists FROM input
)
SELECT pt.connected, pd.data_exists FROM pt, pd
`

type GetOuraStatusRow struct {
	Connected  bool
	DataExists bool
}

func (q *Queries) GetOuraStatus(ctx context.Context, dollar_1 uuid.UUID) (GetOuraStatusRow, error) {
	row := q.queryRow(ctx, q.getOuraStatusStmt, getOuraStatus, dollar_1)
	var i GetOuraStatusRow
	err := row.Scan(&i.Connected, &i.DataExists)
	return i, err
}

const getOuraTokenByOuraID = `-- name: GetOuraTokenByOuraID :one
SELECT user_id, data
FROM oura_tokens
WHERE data->'personal_info'->>'id' = $1::text
`

func (q *Queries) GetOuraTokenByOuraID(ctx context.Context, dollar_1 string) (OuraToken, error) {
	row := q.queryRow(ctx, q.getOuraTokenByOuraIDStmt, getOuraTokenByOuraID, dollar_1)
	var i OuraToken
	err := row.Scan(&i.UserID, &i.Data)
	return i, err
}

const getPolarStatus = `-- name: GetPolarStatus :one
WITH input AS (
  SELECT $1::uuid AS uid
),
pt AS (
  SELECT EXISTS(SELECT 1 FROM polar_tokens WHERE user_id = input.uid) AS connected FROM input
),
pd AS (
  SELECT EXISTS(SELECT 1 FROM polar_data WHERE user_id = input.uid) AS data_exists FROM input
)
SELECT pt.connected, pd.data_exists FROM pt, pd
`

type GetPolarStatusRow struct {
	Connected  bool
	DataExists bool
}

func (q *Queries) GetPolarStatus(ctx context.Context, dollar_1 uuid.UUID) (GetPolarStatusRow, error) {
	row := q.queryRow(ctx, q.getPolarStatusStmt, getPolarStatus, dollar_1)
	var i GetPolarStatusRow
	err := row.Scan(&i.Connected, &i.DataExists)
	return i, err
}

const getPolarTokenByPolarID = `-- name: GetPolarTokenByPolarID :one
SELECT user_id, data
FROM polar_tokens
WHERE data->>'x_user_id' = $1::text
`

func (q *Queries) GetPolarTokenByPolarID(ctx context.Context, dollar_1 string) (PolarToken, error) {
	row := q.queryRow(ctx, q.getPolarTokenByPolarIDStmt, getPolarTokenByPolarID, dollar_1)
	var i PolarToken
	err := row.Scan(&i.UserID, &i.Data)
	return i, err
}

const getSuuntoStatus = `-- name: GetSuuntoStatus :one
WITH input AS (
  SELECT $1::uuid AS uid
),
pt AS (
  SELECT EXISTS(SELECT 1 FROM suunto_tokens WHERE user_id = input.uid) AS connected FROM input
),
pd AS (
  SELECT EXISTS(SELECT 1 FROM suunto_data WHERE user_id = input.uid) AS data_exists FROM input
)
SELECT pt.connected, pd.data_exists FROM pt, pd
`

type GetSuuntoStatusRow struct {
	Connected  bool
	DataExists bool
}

func (q *Queries) GetSuuntoStatus(ctx context.Context, dollar_1 uuid.UUID) (GetSuuntoStatusRow, error) {
	row := q.queryRow(ctx, q.getSuuntoStatusStmt, getSuuntoStatus, dollar_1)
	var i GetSuuntoStatusRow
	err := row.Scan(&i.Connected, &i.DataExists)
	return i, err
}

const getSuuntoTokenByUsername = `-- name: GetSuuntoTokenByUsername :one
SELECT user_id, data
FROM suunto_tokens
WHERE data->>'user' = $1::text
`

func (q *Queries) GetSuuntoTokenByUsername(ctx context.Context, dollar_1 string) (SuuntoToken, error) {
	row := q.queryRow(ctx, q.getSuuntoTokenByUsernameStmt, getSuuntoTokenByUsername, dollar_1)
	var i SuuntoToken
	err := row.Scan(&i.UserID, &i.Data)
	return i, err
}

const getKlabStatus = `-- name: GetKlabStatus :one
SELECT EXISTS(SELECT 1 FROM klab_tokens WHERE user_id = $1) AS connected
`

func (q *Queries) GetKlabStatus(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.queryRow(ctx, q.getKlabStatusStmt, getKlabStatus, userID)
	var connected bool
	err := row.Scan(&connected)
	return connected, err
}

const upsertKlabToken = `-- name: UpsertKlabToken :exec
INSERT INTO klab_tokens (user_id, data)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE SET data = $2
`

type UpsertKlabTokenParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
}

func (q *Queries) UpsertKlabToken(ctx context.Context, arg UpsertKlabTokenParams) error {
	_, err := q.exec(ctx, q.upsertKlabTokenStmt, upsertKlabToken, arg.UserID, arg.Data)
	return err
}

const deleteGarminToken = `-- name: DeleteGarminToken :exec
DELETE FROM garmin_tokens WHERE user_id = $1
`

func (q *Queries) DeleteGarminToken(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteGarminTokenStmt, deleteGarminToken, userID)
	return err
}

const deleteKlabToken = `-- name: DeleteKlabToken :exec
DELETE FROM klab_tokens WHERE user_id = $1
`

func (q *Queries) DeleteKlabToken(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteKlabTokenStmt, deleteKlabToken, userID)
	return err
}

const deleteOuraToken = `-- name: DeleteOuraToken :exec
DELETE FROM oura_tokens WHERE user_id = $1
`

func (q *Queries) DeleteOuraToken(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteOuraTokenStmt, deleteOuraToken, userID)
	return err
}

const deletePolarToken = `-- name: DeletePolarToken :exec
DELETE FROM polar_tokens WHERE user_id = $1
`

func (q *Queries) DeletePolarToken(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.deletePolarTokenStmt, deletePolarToken, userID)
	return err
}

const deleteSuuntoToken = `-- name: DeleteSuuntoToken :exec
DELETE FROM suunto_tokens WHERE user_id = $1
`

func (q *Queries) DeleteSuuntoToken(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteSuuntoTokenStmt, deleteSuuntoToken, userID)
	return err
}

const getGarminTokensForUpdate = `-- name: GetGarminTokensForUpdate :many
SELECT user_id, data FROM garmin_tokens
WHERE (data ->> 'token_last_refreshed')::timestamp < $1::timestamp
`

func (q *Queries) GetGarminTokensForUpdate(ctx context.Context, cutoff time.Time) ([]GarminToken, error) {
	rows, err := q.query(ctx, q.getGarminTokensForUpdateStmt, getGarminTokensForUpdate, cutoff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GarminToken
	for rows.Next() {
		var i GarminToken
		if err := rows.Scan(&i.UserID, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOuraTokensForUpdate = `-- name: GetOuraTokensForUpdate :many
SELECT user_id, data FROM oura_tokens
WHERE (data ->> 'token_last_refreshed')::timestamp < $1::timestamp
`

func (q *Queries) GetOuraTokensForUpdate(ctx context.Context, cutoff time.Time) ([]OuraToken, error) {
	rows, err := q.query(ctx, q.getOuraTokensForUpdateStmt, getOuraTokensForUpdate, cutoff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OuraToken
	for rows.Next() {
		var i OuraToken
		if err := rows.Scan(&i.UserID, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPolarTokensForUpdate = `-- name: GetPolarTokensForUpdate :many
SELECT user_id, data FROM polar_tokens
WHERE (data ->> 'token_last_refreshed')::timestamp < $1::timestamp
`

func (q *Queries) GetPolarTokensForUpdate(ctx context.Context, cutoff time.Time) ([]PolarToken, error) {
	rows, err := q.query(ctx, q.getPolarTokensForUpdateStmt, getPolarTokensForUpdate, cutoff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolarToken
	for rows.Next() {
		var i PolarToken
		if err := rows.Scan(&i.UserID, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuuntoTokensForUpdate = `-- name: GetSuuntoTokensForUpdate :many
SELECT user_id, data FROM suunto_tokens
WHERE (data ->> 'token_last_refreshed')::timestamp < $1::timestamp
`

func (q *Queries) GetSuuntoTokensForUpdate(ctx context.Context, cutoff time.Time) ([]SuuntoToken, error) {
	rows, err := q.query(ctx, q.getSuuntoTokensForUpdateStmt, getSuuntoTokensForUpdate, cutoff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SuuntoToken
	for rows.Next() {
		var i SuuntoToken
		if err := rows.Scan(&i.UserID, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
