// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package kamksqlc

import (
	"context"
	"database/sql"
	"time"
)

const deleteInjuryByID = `-- name: DeleteInjuryByID :execrows
DELETE FROM public.injuries
WHERE competitor_id = $1
  AND injury_id     = $2
`

type DeleteInjuryByIDParams struct {
	CompetitorID int32
	InjuryID     sql.NullInt32
}

func (q *Queries) DeleteInjuryByID(ctx context.Context, arg DeleteInjuryByIDParams) (int64, error) {
	result, err := q.exec(ctx, q.deleteInjuryByIDStmt, deleteInjuryByID, arg.CompetitorID, arg.InjuryID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteQuestionnaireByTimestamp = `-- name: DeleteQuestionnaireByTimestamp :execrows
DELETE FROM public.querys
WHERE competitor_id = $1
  AND "timestamp" >= date_trunc('minute', $2::timestamptz)
  AND "timestamp" <  date_trunc('minute', $2::timestamptz) + interval '1 minute'
`

type DeleteQuestionnaireByTimestampParams struct {
	CompetitorID int32
	Timestamp    time.Time
}

func (q *Queries) DeleteQuestionnaireByTimestamp(ctx context.Context, arg DeleteQuestionnaireByTimestampParams) (int64, error) {
	result, err := q.exec(ctx, q.deleteQuestionnaireByTimestampStmt, deleteQuestionnaireByTimestamp, arg.CompetitorID, arg.Timestamp)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getActiveInjuriesByUser = `-- name: GetActiveInjuriesByUser :many
SELECT
  competitor_id,
  injury_type,
  severity,
  pain_level,
  description,
  date_start,
  status,
  date_end,
  injury_id,
  meta
FROM public.injuries
WHERE competitor_id = $1
  AND status = 0
ORDER BY date_start DESC
`

func (q *Queries) GetActiveInjuriesByUser(ctx context.Context, competitorID int32) ([]Injury, error) {
	rows, err := q.query(ctx, q.getActiveInjuriesByUserStmt, getActiveInjuriesByUser, competitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Injury
	for rows.Next() {
		var i Injury
		if err := rows.Scan(
			&i.CompetitorID,
			&i.InjuryType,
			&i.Severity,
			&i.PainLevel,
			&i.Description,
			&i.DateStart,
			&i.Status,
			&i.DateEnd,
			&i.InjuryID,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxInjuryIDForUser = `-- name: GetMaxInjuryIDForUser :one
SELECT COALESCE(MAX(injury_id), 0)::int4 AS id
FROM public.injuries
WHERE competitor_id = $1
`

func (q *Queries) GetMaxInjuryIDForUser(ctx context.Context, competitorID int32) (int32, error) {
	row := q.queryRow(ctx, q.getMaxInjuryIDForUserStmt, getMaxInjuryIDForUser, competitorID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getQuestionnairesByUser = `-- name: GetQuestionnairesByUser :many
SELECT
  competitor_id,
  query_type,
  answers,
  comment,
  "timestamp",
  meta
FROM public.querys
WHERE competitor_id = $1
ORDER BY "timestamp" DESC
`

func (q *Queries) GetQuestionnairesByUser(ctx context.Context, competitorID int32) ([]Query, error) {
	rows, err := q.query(ctx, q.getQuestionnairesByUserStmt, getQuestionnairesByUser, competitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Query
	for rows.Next() {
		var i Query
		if err := rows.Scan(
			&i.CompetitorID,
			&i.QueryType,
			&i.Answers,
			&i.Comment,
			&i.Timestamp,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertInjury = `-- name: InsertInjury :exec
INSERT INTO public.injuries (
  competitor_id, injury_type, severity, pain_level, description, date_start, status, injury_id, meta
) VALUES (
  $1, $2, $3, $4, $5, NOW(), 0, $6, $7
)
`

type InsertInjuryParams struct {
	CompetitorID int32
	InjuryType   int32
	Severity     sql.NullInt32
	PainLevel    sql.NullInt32
	Description  sql.NullString
	InjuryID     sql.NullInt32
	Meta         sql.NullString
}

func (q *Queries) InsertInjury(ctx context.Context, arg InsertInjuryParams) error {
	_, err := q.exec(ctx, q.insertInjuryStmt, insertInjury,
		arg.CompetitorID,
		arg.InjuryType,
		arg.Severity,
		arg.PainLevel,
		arg.Description,
		arg.InjuryID,
		arg.Meta,
	)
	return err
}

const insertQuestionnaire = `-- name: InsertQuestionnaire :exec
INSERT INTO public.querys (
  competitor_id, query_type, answers, comment, "timestamp", meta
) VALUES (
  $1, $2, $3, $4, NOW(), $5
)
`

type InsertQuestionnaireParams struct {
	CompetitorID int32
	QueryType    sql.NullInt32
	Answers      sql.NullString
	Comment      sql.NullString
	Meta         sql.NullString
}

func (q *Queries) InsertQuestionnaire(ctx context.Context, arg InsertQuestionnaireParams) error {
	_, err := q.exec(ctx, q.insertQuestionnaireStmt, insertQuestionnaire,
		arg.CompetitorID,
		arg.QueryType,
		arg.Answers,
		arg.Comment,
		arg.Meta,
	)
	return err
}

const isQuizDoneToday = `-- name: IsQuizDoneToday :many
SELECT
  competitor_id, query_type, answers, comment, "timestamp", meta
FROM public.querys
WHERE competitor_id = $1
  AND query_type    = $2
  AND "timestamp"  >= $3
  AND "timestamp"  <  $4
`

type IsQuizDoneTodayParams struct {
	CompetitorID int32
	QueryType    sql.NullInt32
	Timestamp    time.Time
	Timestamp_2  time.Time
}

func (q *Queries) IsQuizDoneToday(ctx context.Context, arg IsQuizDoneTodayParams) ([]Query, error) {
	rows, err := q.query(ctx, q.isQuizDoneTodayStmt, isQuizDoneToday,
		arg.CompetitorID,
		arg.QueryType,
		arg.Timestamp,
		arg.Timestamp_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Query
	for rows.Next() {
		var i Query
		if err := rows.Scan(
			&i.CompetitorID,
			&i.QueryType,
			&i.Answers,
			&i.Comment,
			&i.Timestamp,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInjuryRecoveredByID = `-- name: MarkInjuryRecoveredByID :exec
UPDATE public.injuries
SET status = 1,
    date_end = NOW()
WHERE injury_id = $1
  AND competitor_id = $2
`

type MarkInjuryRecoveredByIDParams struct {
	InjuryID     sql.NullInt32
	CompetitorID int32
}

func (q *Queries) MarkInjuryRecoveredByID(ctx context.Context, arg MarkInjuryRecoveredByIDParams) error {
	_, err := q.exec(ctx, q.markInjuryRecoveredByIDStmt, markInjuryRecoveredByID, arg.InjuryID, arg.CompetitorID)
	return err
}

const updateQuestionnaireByTimestamp = `-- name: UpdateQuestionnaireByTimestamp :execrows
UPDATE public.querys
SET answers = $3,
    comment = $4
WHERE competitor_id = $1
  AND "timestamp" >= date_trunc('minute', $2::timestamptz)
  AND "timestamp" <  date_trunc('minute', $2::timestamptz) + interval '1 minute'
`

type UpdateQuestionnaireByTimestampParams struct {
	CompetitorID int32
	Timestamp    time.Time
	Answers      sql.NullString
	Comment      sql.NullString
}

func (q *Queries) UpdateQuestionnaireByTimestamp(ctx context.Context, arg UpdateQuestionnaireByTimestampParams) (int64, error) {
	result, err := q.exec(ctx, q.updateQuestionnaireByTimestampStmt, updateQuestionnaireByTimestamp,
		arg.CompetitorID,
		arg.Timestamp,
		arg.Answers,
		arg.Comment,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
