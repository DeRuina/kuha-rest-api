// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package kamksqlc

import (
	"context"
	"database/sql"
)

const getActiveInjuriesByUser = `-- name: GetActiveInjuriesByUser :many
SELECT
  competitor_id,
  injury_type,
  severity,
  pain_level,
  description,
  date_start,
  status,
  date_end,
  injury_id,
  meta
FROM public.injuries
WHERE competitor_id = $1
  AND status = 0
ORDER BY date_start DESC
`

func (q *Queries) GetActiveInjuriesByUser(ctx context.Context, competitorID sql.NullInt32) ([]Injury, error) {
	rows, err := q.query(ctx, q.getActiveInjuriesByUserStmt, getActiveInjuriesByUser, competitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Injury
	for rows.Next() {
		var i Injury
		if err := rows.Scan(
			&i.CompetitorID,
			&i.InjuryType,
			&i.Severity,
			&i.PainLevel,
			&i.Description,
			&i.DateStart,
			&i.Status,
			&i.DateEnd,
			&i.InjuryID,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxInjuryIDForUser = `-- name: GetMaxInjuryIDForUser :one
SELECT COALESCE(MAX(injury_id), 0) AS id
FROM public.injuries
WHERE competitor_id = $1
`

func (q *Queries) GetMaxInjuryIDForUser(ctx context.Context, competitorID sql.NullInt32) (interface{}, error) {
	row := q.queryRow(ctx, q.getMaxInjuryIDForUserStmt, getMaxInjuryIDForUser, competitorID)
	var id interface{}
	err := row.Scan(&id)
	return id, err
}

const getQuestionnairesByUserV2 = `-- name: GetQuestionnairesByUserV2 :many
SELECT
  competitor_id,
  query_type,
  answers,
  comment,
  "timestamp",
  meta
FROM public.querys_v2
WHERE competitor_id = $1
ORDER BY "timestamp" DESC
`

func (q *Queries) GetQuestionnairesByUserV2(ctx context.Context, competitorID sql.NullInt32) ([]QuerysV2, error) {
	rows, err := q.query(ctx, q.getQuestionnairesByUserV2Stmt, getQuestionnairesByUserV2, competitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuerysV2
	for rows.Next() {
		var i QuerysV2
		if err := rows.Scan(
			&i.CompetitorID,
			&i.QueryType,
			&i.Answers,
			&i.Comment,
			&i.Timestamp,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertInjury = `-- name: InsertInjury :exec
INSERT INTO public.injuries (
  competitor_id, injury_type, severity, pain_level, description, date_start, status, injury_id, meta
) VALUES (
  $1, $2, $3, $4, $5, NOW(), 0, $6, $7
)
`

type InsertInjuryParams struct {
	CompetitorID sql.NullInt32
	InjuryType   sql.NullInt32
	Severity     sql.NullInt32
	PainLevel    sql.NullInt32
	Description  sql.NullString
	InjuryID     sql.NullInt32
	Meta         sql.NullString
}

func (q *Queries) InsertInjury(ctx context.Context, arg InsertInjuryParams) error {
	_, err := q.exec(ctx, q.insertInjuryStmt, insertInjury,
		arg.CompetitorID,
		arg.InjuryType,
		arg.Severity,
		arg.PainLevel,
		arg.Description,
		arg.InjuryID,
		arg.Meta,
	)
	return err
}

const insertQuestionnaireV2 = `-- name: InsertQuestionnaireV2 :exec
INSERT INTO public.querys_v2 (
  competitor_id, query_type, answers, comment, "timestamp", meta
) VALUES (
  $1, $2, $3, $4, NOW(), $5
)
`

type InsertQuestionnaireV2Params struct {
	CompetitorID sql.NullInt32
	QueryType    sql.NullInt32
	Answers      sql.NullString
	Comment      sql.NullString
	Meta         sql.NullString
}

func (q *Queries) InsertQuestionnaireV2(ctx context.Context, arg InsertQuestionnaireV2Params) error {
	_, err := q.exec(ctx, q.insertQuestionnaireV2Stmt, insertQuestionnaireV2,
		arg.CompetitorID,
		arg.QueryType,
		arg.Answers,
		arg.Comment,
		arg.Meta,
	)
	return err
}

const isQuizDoneTodayV2 = `-- name: IsQuizDoneTodayV2 :many
SELECT
  competitor_id, query_type, answers, comment, "timestamp", meta
FROM public.querys_v2
WHERE competitor_id = $1
  AND query_type = $2
  AND "timestamp" >= $3
  AND "timestamp" <  $4
`

type IsQuizDoneTodayV2Params struct {
	CompetitorID sql.NullInt32
	QueryType    sql.NullInt32
	Timestamp    sql.NullTime
	Timestamp_2  sql.NullTime
}

func (q *Queries) IsQuizDoneTodayV2(ctx context.Context, arg IsQuizDoneTodayV2Params) ([]QuerysV2, error) {
	rows, err := q.query(ctx, q.isQuizDoneTodayV2Stmt, isQuizDoneTodayV2,
		arg.CompetitorID,
		arg.QueryType,
		arg.Timestamp,
		arg.Timestamp_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuerysV2
	for rows.Next() {
		var i QuerysV2
		if err := rows.Scan(
			&i.CompetitorID,
			&i.QueryType,
			&i.Answers,
			&i.Comment,
			&i.Timestamp,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInjuryRecoveredByID = `-- name: MarkInjuryRecoveredByID :exec
UPDATE public.injuries
SET status = 1,
    date_end = NOW()
WHERE injury_id = $1
  AND competitor_id = $2
`

type MarkInjuryRecoveredByIDParams struct {
	InjuryID     sql.NullInt32
	CompetitorID sql.NullInt32
}

func (q *Queries) MarkInjuryRecoveredByID(ctx context.Context, arg MarkInjuryRecoveredByIDParams) error {
	_, err := q.exec(ctx, q.markInjuryRecoveredByIDStmt, markInjuryRecoveredByID, arg.InjuryID, arg.CompetitorID)
	return err
}

const updateQuestionnaireByTimestampV2 = `-- name: UpdateQuestionnaireByTimestampV2 :exec
UPDATE public.querys_v2
SET answers = $3,
    comment = $4
WHERE competitor_id = $1
  AND "timestamp" = $2
`

type UpdateQuestionnaireByTimestampV2Params struct {
	CompetitorID sql.NullInt32
	Timestamp    sql.NullTime
	Answers      sql.NullString
	Comment      sql.NullString
}

func (q *Queries) UpdateQuestionnaireByTimestampV2(ctx context.Context, arg UpdateQuestionnaireByTimestampV2Params) error {
	_, err := q.exec(ctx, q.updateQuestionnaireByTimestampV2Stmt, updateQuestionnaireByTimestampV2,
		arg.CompetitorID,
		arg.Timestamp,
		arg.Answers,
		arg.Comment,
	)
	return err
}
