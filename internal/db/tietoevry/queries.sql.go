// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package tietoevrysqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const deleteUser = `-- name: DeleteUser :execrows
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.exec(ctx, q.deleteUserStmt, deleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getActivityZonesByUser = `-- name: GetActivityZonesByUser :many
SELECT user_id, date, created_at, updated_at, seconds_in_zone_0, seconds_in_zone_1, seconds_in_zone_2, seconds_in_zone_3, seconds_in_zone_4, seconds_in_zone_5, source, raw_data FROM activity_zones
WHERE user_id = $1
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetActivityZonesByUser(ctx context.Context, userID uuid.UUID) ([]ActivityZone, error) {
	rows, err := q.query(ctx, q.getActivityZonesByUserStmt, getActivityZonesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityZone
	for rows.Next() {
		var i ActivityZone
		if err := rows.Scan(
			&i.UserID,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SecondsInZone0,
			&i.SecondsInZone1,
			&i.SecondsInZone2,
			&i.SecondsInZone3,
			&i.SecondsInZone4,
			&i.SecondsInZone5,
			&i.Source,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedUsers = `-- name: GetDeletedUsers :many
SELECT id, user_id, sportti_id, deleted_at
FROM deleted_users_log
ORDER BY deleted_at DESC
`

func (q *Queries) GetDeletedUsers(ctx context.Context) ([]DeletedUsersLog, error) {
	rows, err := q.query(ctx, q.getDeletedUsersStmt, getDeletedUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeletedUsersLog
	for rows.Next() {
		var i DeletedUsersLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SporttiID,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseHRZones = `-- name: GetExerciseHRZones :many
SELECT exercise_id, zone_index, seconds_in_zone, lower_limit, upper_limit, created_at, updated_at FROM exercise_hr_zones
WHERE exercise_id = $1
ORDER BY zone_index
`

func (q *Queries) GetExerciseHRZones(ctx context.Context, exerciseID uuid.UUID) ([]ExerciseHrZone, error) {
	rows, err := q.query(ctx, q.getExerciseHRZonesStmt, getExerciseHRZones, exerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExerciseHrZone
	for rows.Next() {
		var i ExerciseHrZone
		if err := rows.Scan(
			&i.ExerciseID,
			&i.ZoneIndex,
			&i.SecondsInZone,
			&i.LowerLimit,
			&i.UpperLimit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseSamples = `-- name: GetExerciseSamples :many
SELECT id, user_id, exercise_id, sample_type, recording_rate, samples, source FROM exercise_samples
WHERE exercise_id = $1
`

func (q *Queries) GetExerciseSamples(ctx context.Context, exerciseID uuid.UUID) ([]ExerciseSample, error) {
	rows, err := q.query(ctx, q.getExerciseSamplesStmt, getExerciseSamples, exerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExerciseSample
	for rows.Next() {
		var i ExerciseSample
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExerciseID,
			&i.SampleType,
			&i.RecordingRate,
			pq.Array(&i.Samples),
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseSections = `-- name: GetExerciseSections :many
SELECT id, user_id, exercise_id, created_at, updated_at, start_time, end_time, section_type, name, comment, source, raw_id, raw_data FROM exercise_sections
WHERE exercise_id = $1
ORDER BY start_time
`

func (q *Queries) GetExerciseSections(ctx context.Context, exerciseID uuid.UUID) ([]ExerciseSection, error) {
	rows, err := q.query(ctx, q.getExerciseSectionsStmt, getExerciseSections, exerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExerciseSection
	for rows.Next() {
		var i ExerciseSection
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExerciseID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartTime,
			&i.EndTime,
			&i.SectionType,
			&i.Name,
			&i.Comment,
			&i.Source,
			&i.RawID,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesByUser = `-- name: GetExercisesByUser :many
SELECT id, created_at, updated_at, user_id, start_time, duration, comment, sport_type, detailed_sport_type, distance, avg_heart_rate, max_heart_rate, trimp, sprint_count, avg_speed, max_speed, source, status, calories, training_load, raw_id, raw_data, feeling, recovery, rpe FROM exercises
WHERE user_id = $1
ORDER BY start_time DESC
`

func (q *Queries) GetExercisesByUser(ctx context.Context, userID uuid.UUID) ([]Exercise, error) {
	rows, err := q.query(ctx, q.getExercisesByUserStmt, getExercisesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.StartTime,
			&i.Duration,
			&i.Comment,
			&i.SportType,
			&i.DetailedSportType,
			&i.Distance,
			&i.AvgHeartRate,
			&i.MaxHeartRate,
			&i.Trimp,
			&i.SprintCount,
			&i.AvgSpeed,
			&i.MaxSpeed,
			&i.Source,
			&i.Status,
			&i.Calories,
			&i.TrainingLoad,
			&i.RawID,
			&i.RawData,
			&i.Feeling,
			&i.Recovery,
			&i.Rpe,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeasurementsByUser = `-- name: GetMeasurementsByUser :many
SELECT id, created_at, updated_at, user_id, date, name, name_type, source, value, value_numeric, comment, raw_id, raw_data, additional_info FROM measurements
WHERE user_id = $1
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetMeasurementsByUser(ctx context.Context, userID uuid.UUID) ([]Measurement, error) {
	rows, err := q.query(ctx, q.getMeasurementsByUserStmt, getMeasurementsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Measurement
	for rows.Next() {
		var i Measurement
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Date,
			&i.Name,
			&i.NameType,
			&i.Source,
			&i.Value,
			&i.ValueNumeric,
			&i.Comment,
			&i.RawID,
			&i.RawData,
			&i.AdditionalInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionnairesByUser = `-- name: GetQuestionnairesByUser :many
SELECT user_id, questionnaire_instance_id, questionnaire_name_fi, questionnaire_name_en, questionnaire_key, question_id, question_label_fi, question_label_en, question_type, option_id, option_value, option_label_fi, option_label_en, free_text, created_at, updated_at, value FROM question_answers
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetQuestionnairesByUser(ctx context.Context, userID uuid.UUID) ([]QuestionAnswer, error) {
	rows, err := q.query(ctx, q.getQuestionnairesByUserStmt, getQuestionnairesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuestionAnswer
	for rows.Next() {
		var i QuestionAnswer
		if err := rows.Scan(
			&i.UserID,
			&i.QuestionnaireInstanceID,
			&i.QuestionnaireNameFi,
			&i.QuestionnaireNameEn,
			&i.QuestionnaireKey,
			&i.QuestionID,
			&i.QuestionLabelFi,
			&i.QuestionLabelEn,
			&i.QuestionType,
			&i.OptionID,
			&i.OptionValue,
			&i.OptionLabelFi,
			&i.OptionLabelEn,
			&i.FreeText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSymptomsByUser = `-- name: GetSymptomsByUser :many
SELECT id, user_id, date, symptom, severity, comment, source, created_at, updated_at, raw_id, original_id, recovered, pain_index, side, category, additional_data FROM symptoms
WHERE user_id = $1
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetSymptomsByUser(ctx context.Context, userID uuid.UUID) ([]Symptom, error) {
	rows, err := q.query(ctx, q.getSymptomsByUserStmt, getSymptomsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Symptom
	for rows.Next() {
		var i Symptom
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Symptom,
			&i.Severity,
			&i.Comment,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RawID,
			&i.OriginalID,
			&i.Recovered,
			&i.PainIndex,
			&i.Side,
			&i.Category,
			&i.AdditionalData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestResultsByUser = `-- name: GetTestResultsByUser :many
SELECT id, user_id, type_id, type_type, type_result_type, type_name, timestamp, name, comment, data, created_at, updated_at, test_event_id, test_event_name, test_event_date, test_event_template_test_id, test_event_template_test_name, test_event_template_test_limits FROM test_results
WHERE user_id = $1
ORDER BY timestamp DESC, created_at DESC
`

func (q *Queries) GetTestResultsByUser(ctx context.Context, userID uuid.UUID) ([]TestResult, error) {
	rows, err := q.query(ctx, q.getTestResultsByUserStmt, getTestResultsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestResult
	for rows.Next() {
		var i TestResult
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TypeID,
			&i.TypeType,
			&i.TypeResultType,
			&i.TypeName,
			&i.Timestamp,
			&i.Name,
			&i.Comment,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TestEventID,
			&i.TestEventName,
			&i.TestEventDate,
			&i.TestEventTemplateTestID,
			&i.TestEventTemplateTestName,
			&i.TestEventTemplateTestLimits,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, sportti_id, profile_gender, profile_birthdate, profile_weight, profile_height, profile_resting_heart_rate, profile_maximum_heart_rate, profile_aerobic_threshold, profile_anaerobic_threshold, profile_vo2max FROM users WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.SporttiID,
		&i.ProfileGender,
		&i.ProfileBirthdate,
		&i.ProfileWeight,
		&i.ProfileHeight,
		&i.ProfileRestingHeartRate,
		&i.ProfileMaximumHeartRate,
		&i.ProfileAerobicThreshold,
		&i.ProfileAnaerobicThreshold,
		&i.ProfileVo2max,
	)
	return i, err
}

const insertActivityZone = `-- name: InsertActivityZone :exec
INSERT INTO activity_zones (
    user_id, date, created_at, updated_at,
    seconds_in_zone_0, seconds_in_zone_1, seconds_in_zone_2,
    seconds_in_zone_3, seconds_in_zone_4, seconds_in_zone_5,
    source, raw_data
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7,
    $8, $9, $10,
    $11, $12
)
ON CONFLICT (user_id, date, source) DO UPDATE SET
  updated_at       = GREATEST(activity_zones.updated_at, EXCLUDED.updated_at),
  seconds_in_zone_0= EXCLUDED.seconds_in_zone_0,
  seconds_in_zone_1= EXCLUDED.seconds_in_zone_1,
  seconds_in_zone_2= EXCLUDED.seconds_in_zone_2,
  seconds_in_zone_3= EXCLUDED.seconds_in_zone_3,
  seconds_in_zone_4= EXCLUDED.seconds_in_zone_4,
  seconds_in_zone_5= EXCLUDED.seconds_in_zone_5,
  raw_data         = EXCLUDED.raw_data
`

type InsertActivityZoneParams struct {
	UserID         uuid.UUID
	Date           time.Time
	CreatedAt      time.Time
	UpdatedAt      time.Time
	SecondsInZone0 sql.NullFloat64
	SecondsInZone1 sql.NullFloat64
	SecondsInZone2 sql.NullFloat64
	SecondsInZone3 sql.NullFloat64
	SecondsInZone4 sql.NullFloat64
	SecondsInZone5 sql.NullFloat64
	Source         string
	RawData        pqtype.NullRawMessage
}

func (q *Queries) InsertActivityZone(ctx context.Context, arg InsertActivityZoneParams) error {
	_, err := q.exec(ctx, q.insertActivityZoneStmt, insertActivityZone,
		arg.UserID,
		arg.Date,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.SecondsInZone0,
		arg.SecondsInZone1,
		arg.SecondsInZone2,
		arg.SecondsInZone3,
		arg.SecondsInZone4,
		arg.SecondsInZone5,
		arg.Source,
		arg.RawData,
	)
	return err
}

const insertExercise = `-- name: InsertExercise :exec
INSERT INTO exercises (
    id, created_at, updated_at, user_id, start_time, duration,
    comment, sport_type, detailed_sport_type, distance, avg_heart_rate,
    max_heart_rate, trimp, sprint_count, avg_speed, max_speed,
    source, status, calories, training_load, raw_id,
    feeling, recovery, rpe, raw_data
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11,
    $12, $13, $14, $15, $16,
    $17, $18, $19, $20, $21,
    $22, $23, $24, $25
)
ON CONFLICT (id) DO UPDATE SET
  updated_at          = GREATEST(exercises.updated_at, EXCLUDED.updated_at),
  start_time          = EXCLUDED.start_time,
  duration            = EXCLUDED.duration,
  comment             = EXCLUDED.comment,
  sport_type          = EXCLUDED.sport_type,
  detailed_sport_type = EXCLUDED.detailed_sport_type,
  distance            = EXCLUDED.distance,
  avg_heart_rate      = EXCLUDED.avg_heart_rate,
  max_heart_rate      = EXCLUDED.max_heart_rate,
  trimp               = EXCLUDED.trimp,
  sprint_count        = EXCLUDED.sprint_count,
  avg_speed           = EXCLUDED.avg_speed,
  max_speed           = EXCLUDED.max_speed,
  status              = EXCLUDED.status,
  calories            = EXCLUDED.calories,
  training_load       = EXCLUDED.training_load,
  feeling             = EXCLUDED.feeling,
  recovery            = EXCLUDED.recovery,
  rpe                 = EXCLUDED.rpe,
  raw_data            = EXCLUDED.raw_data
`

type InsertExerciseParams struct {
	ID                uuid.UUID
	CreatedAt         time.Time
	UpdatedAt         time.Time
	UserID            uuid.UUID
	StartTime         time.Time
	Duration          string
	Comment           sql.NullString
	SportType         sql.NullString
	DetailedSportType sql.NullString
	Distance          sql.NullFloat64
	AvgHeartRate      sql.NullFloat64
	MaxHeartRate      sql.NullFloat64
	Trimp             sql.NullFloat64
	SprintCount       sql.NullInt32
	AvgSpeed          sql.NullFloat64
	MaxSpeed          sql.NullFloat64
	Source            string
	Status            sql.NullString
	Calories          sql.NullInt32
	TrainingLoad      sql.NullInt32
	RawID             sql.NullString
	Feeling           sql.NullInt32
	Recovery          sql.NullInt32
	Rpe               sql.NullInt32
	RawData           pqtype.NullRawMessage
}

func (q *Queries) InsertExercise(ctx context.Context, arg InsertExerciseParams) error {
	_, err := q.exec(ctx, q.insertExerciseStmt, insertExercise,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UserID,
		arg.StartTime,
		arg.Duration,
		arg.Comment,
		arg.SportType,
		arg.DetailedSportType,
		arg.Distance,
		arg.AvgHeartRate,
		arg.MaxHeartRate,
		arg.Trimp,
		arg.SprintCount,
		arg.AvgSpeed,
		arg.MaxSpeed,
		arg.Source,
		arg.Status,
		arg.Calories,
		arg.TrainingLoad,
		arg.RawID,
		arg.Feeling,
		arg.Recovery,
		arg.Rpe,
		arg.RawData,
	)
	return err
}

const insertExerciseHRZone = `-- name: InsertExerciseHRZone :exec
INSERT INTO exercise_hr_zones (
    exercise_id, zone_index, seconds_in_zone,
    lower_limit, upper_limit, created_at, updated_at
) VALUES (
    $1, $2, $3,
    $4, $5, $6, $7
)
ON CONFLICT (exercise_id, zone_index) DO UPDATE SET
  seconds_in_zone = EXCLUDED.seconds_in_zone,
  lower_limit     = EXCLUDED.lower_limit,
  upper_limit     = EXCLUDED.upper_limit,
  updated_at      = GREATEST(exercise_hr_zones.updated_at, EXCLUDED.updated_at)
`

type InsertExerciseHRZoneParams struct {
	ExerciseID    uuid.UUID
	ZoneIndex     int32
	SecondsInZone int32
	LowerLimit    int32
	UpperLimit    int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) InsertExerciseHRZone(ctx context.Context, arg InsertExerciseHRZoneParams) error {
	_, err := q.exec(ctx, q.insertExerciseHRZoneStmt, insertExerciseHRZone,
		arg.ExerciseID,
		arg.ZoneIndex,
		arg.SecondsInZone,
		arg.LowerLimit,
		arg.UpperLimit,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const insertExerciseSample = `-- name: InsertExerciseSample :exec
INSERT INTO exercise_samples (
    id, user_id, exercise_id,
    sample_type, recording_rate, samples, source
) VALUES (
    $1, $2, $3,
    $4, $5, $6, $7
)
ON CONFLICT (exercise_id, sample_type) DO UPDATE SET
    recording_rate = EXCLUDED.recording_rate,
    samples = EXCLUDED.samples
`

type InsertExerciseSampleParams struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	ExerciseID    uuid.UUID
	SampleType    string
	RecordingRate int32
	Samples       []float64
	Source        string
}

func (q *Queries) InsertExerciseSample(ctx context.Context, arg InsertExerciseSampleParams) error {
	_, err := q.exec(ctx, q.insertExerciseSampleStmt, insertExerciseSample,
		arg.ID,
		arg.UserID,
		arg.ExerciseID,
		arg.SampleType,
		arg.RecordingRate,
		pq.Array(arg.Samples),
		arg.Source,
	)
	return err
}

const insertExerciseSection = `-- name: InsertExerciseSection :exec
INSERT INTO exercise_sections (
    id, user_id, exercise_id,
    created_at, updated_at, start_time, end_time,
    section_type, name, comment, source, raw_id, raw_data
) VALUES (
    $1, $2, $3,
    $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13
)
ON CONFLICT (id) DO UPDATE SET
  exercise_id = EXCLUDED.exercise_id,
  updated_at  = GREATEST(exercise_sections.updated_at, EXCLUDED.updated_at),
  start_time  = EXCLUDED.start_time,
  end_time    = EXCLUDED.end_time,
  section_type= EXCLUDED.section_type,
  name        = EXCLUDED.name,
  comment     = EXCLUDED.comment,
  raw_data    = EXCLUDED.raw_data
`

type InsertExerciseSectionParams struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	ExerciseID  uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	StartTime   time.Time
	EndTime     time.Time
	SectionType sql.NullString
	Name        sql.NullString
	Comment     sql.NullString
	Source      string
	RawID       sql.NullString
	RawData     pqtype.NullRawMessage
}

func (q *Queries) InsertExerciseSection(ctx context.Context, arg InsertExerciseSectionParams) error {
	_, err := q.exec(ctx, q.insertExerciseSectionStmt, insertExerciseSection,
		arg.ID,
		arg.UserID,
		arg.ExerciseID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.StartTime,
		arg.EndTime,
		arg.SectionType,
		arg.Name,
		arg.Comment,
		arg.Source,
		arg.RawID,
		arg.RawData,
	)
	return err
}

const insertMeasurement = `-- name: InsertMeasurement :exec
INSERT INTO measurements (
    id, created_at, updated_at, user_id, date, name, name_type,
    source, value, value_numeric, comment, raw_id, raw_data, additional_info
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13, $14
)
ON CONFLICT (id) DO UPDATE SET
  updated_at     = GREATEST(measurements.updated_at, EXCLUDED.updated_at),
  name_type      = EXCLUDED.name_type,
  value          = EXCLUDED.value,
  value_numeric  = EXCLUDED.value_numeric,
  comment        = EXCLUDED.comment,
  raw_data       = EXCLUDED.raw_data,
  additional_info= EXCLUDED.additional_info
`

type InsertMeasurementParams struct {
	ID             uuid.UUID
	CreatedAt      time.Time
	UpdatedAt      time.Time
	UserID         uuid.UUID
	Date           time.Time
	Name           string
	NameType       string
	Source         string
	Value          string
	ValueNumeric   sql.NullFloat64
	Comment        sql.NullString
	RawID          sql.NullString
	RawData        pqtype.NullRawMessage
	AdditionalInfo pqtype.NullRawMessage
}

func (q *Queries) InsertMeasurement(ctx context.Context, arg InsertMeasurementParams) error {
	_, err := q.exec(ctx, q.insertMeasurementStmt, insertMeasurement,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UserID,
		arg.Date,
		arg.Name,
		arg.NameType,
		arg.Source,
		arg.Value,
		arg.ValueNumeric,
		arg.Comment,
		arg.RawID,
		arg.RawData,
		arg.AdditionalInfo,
	)
	return err
}

const insertQuestionnaireAnswer = `-- name: InsertQuestionnaireAnswer :exec
INSERT INTO question_answers (
    user_id, questionnaire_instance_id, questionnaire_name_fi,
    questionnaire_name_en, questionnaire_key, question_id, question_label_fi,
    question_label_en, question_type, option_id, option_value,
    option_label_fi, option_label_en, free_text, created_at, updated_at, value
) VALUES (
    $1, $2, $3,
    $4, $5, $6, $7,
    $8, $9, $10, $11,
    $12, $13, $14, $15, $16, $17
)
ON CONFLICT (questionnaire_instance_id, question_id, user_id) DO UPDATE SET
  questionnaire_name_fi = EXCLUDED.questionnaire_name_fi,
  questionnaire_name_en = EXCLUDED.questionnaire_name_en,
  questionnaire_key     = EXCLUDED.questionnaire_key,
  question_label_fi     = EXCLUDED.question_label_fi,
  question_label_en     = EXCLUDED.question_label_en,
  question_type         = EXCLUDED.question_type,
  option_id             = EXCLUDED.option_id,
  option_value          = EXCLUDED.option_value,
  option_label_fi       = EXCLUDED.option_label_fi,
  option_label_en       = EXCLUDED.option_label_en,
  free_text             = EXCLUDED.free_text,
  updated_at            = GREATEST(question_answers.updated_at, EXCLUDED.updated_at),
  value                 = EXCLUDED.value
`

type InsertQuestionnaireAnswerParams struct {
	UserID                  uuid.UUID
	QuestionnaireInstanceID uuid.UUID
	QuestionnaireNameFi     sql.NullString
	QuestionnaireNameEn     sql.NullString
	QuestionnaireKey        string
	QuestionID              uuid.UUID
	QuestionLabelFi         sql.NullString
	QuestionLabelEn         sql.NullString
	QuestionType            string
	OptionID                uuid.NullUUID
	OptionValue             sql.NullInt32
	OptionLabelFi           sql.NullString
	OptionLabelEn           sql.NullString
	FreeText                sql.NullString
	CreatedAt               time.Time
	UpdatedAt               time.Time
	Value                   pqtype.NullRawMessage
}

func (q *Queries) InsertQuestionnaireAnswer(ctx context.Context, arg InsertQuestionnaireAnswerParams) error {
	_, err := q.exec(ctx, q.insertQuestionnaireAnswerStmt, insertQuestionnaireAnswer,
		arg.UserID,
		arg.QuestionnaireInstanceID,
		arg.QuestionnaireNameFi,
		arg.QuestionnaireNameEn,
		arg.QuestionnaireKey,
		arg.QuestionID,
		arg.QuestionLabelFi,
		arg.QuestionLabelEn,
		arg.QuestionType,
		arg.OptionID,
		arg.OptionValue,
		arg.OptionLabelFi,
		arg.OptionLabelEn,
		arg.FreeText,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Value,
	)
	return err
}

const insertSymptom = `-- name: InsertSymptom :exec
INSERT INTO symptoms (
    id, user_id, date, symptom, severity, comment, source,
    created_at, updated_at, raw_id, original_id, recovered,
    pain_index, side, category, additional_data
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12,
    $13, $14, $15, $16
)
ON CONFLICT (id) DO UPDATE SET
  symptom         = EXCLUDED.symptom,
  severity        = EXCLUDED.severity,
  comment         = EXCLUDED.comment,
  updated_at      = GREATEST(symptoms.updated_at, EXCLUDED.updated_at),
  original_id     = EXCLUDED.original_id,
  recovered       = EXCLUDED.recovered,
  pain_index      = EXCLUDED.pain_index,
  side            = EXCLUDED.side,
  category        = EXCLUDED.category,
  additional_data = EXCLUDED.additional_data
`

type InsertSymptomParams struct {
	ID             uuid.UUID
	UserID         uuid.UUID
	Date           time.Time
	Symptom        string
	Severity       int32
	Comment        sql.NullString
	Source         string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	RawID          sql.NullString
	OriginalID     uuid.NullUUID
	Recovered      sql.NullBool
	PainIndex      sql.NullInt32
	Side           sql.NullString
	Category       sql.NullString
	AdditionalData pqtype.NullRawMessage
}

func (q *Queries) InsertSymptom(ctx context.Context, arg InsertSymptomParams) error {
	_, err := q.exec(ctx, q.insertSymptomStmt, insertSymptom,
		arg.ID,
		arg.UserID,
		arg.Date,
		arg.Symptom,
		arg.Severity,
		arg.Comment,
		arg.Source,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.RawID,
		arg.OriginalID,
		arg.Recovered,
		arg.PainIndex,
		arg.Side,
		arg.Category,
		arg.AdditionalData,
	)
	return err
}

const insertTestResult = `-- name: InsertTestResult :exec
INSERT INTO test_results (
    id, user_id, type_id, type_type, type_result_type, type_name,
    timestamp, name, comment, data, created_at, updated_at,
    test_event_id, test_event_name, test_event_date,
    test_event_template_test_id, test_event_template_test_name,
    test_event_template_test_limits
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11, $12,
    $13, $14, $15, $16, $17, $18
)
ON CONFLICT (id) DO UPDATE SET
  type_id                        = EXCLUDED.type_id,
  type_type                      = EXCLUDED.type_type,
  type_result_type               = EXCLUDED.type_result_type,
  type_name                      = EXCLUDED.type_name,
  timestamp                      = EXCLUDED.timestamp,
  name                           = EXCLUDED.name,
  comment                        = EXCLUDED.comment,
  data                           = EXCLUDED.data,
  updated_at                     = GREATEST(test_results.updated_at, EXCLUDED.updated_at),
  test_event_id                  = EXCLUDED.test_event_id,
  test_event_name                = EXCLUDED.test_event_name,
  test_event_date                = EXCLUDED.test_event_date,
  test_event_template_test_id    = EXCLUDED.test_event_template_test_id,
  test_event_template_test_name  = EXCLUDED.test_event_template_test_name,
  test_event_template_test_limits= EXCLUDED.test_event_template_test_limits
`

type InsertTestResultParams struct {
	ID                          uuid.UUID
	UserID                      uuid.UUID
	TypeID                      uuid.UUID
	TypeType                    sql.NullString
	TypeResultType              string
	TypeName                    sql.NullString
	Timestamp                   time.Time
	Name                        sql.NullString
	Comment                     sql.NullString
	Data                        json.RawMessage
	CreatedAt                   time.Time
	UpdatedAt                   time.Time
	TestEventID                 uuid.NullUUID
	TestEventName               sql.NullString
	TestEventDate               sql.NullTime
	TestEventTemplateTestID     uuid.NullUUID
	TestEventTemplateTestName   sql.NullString
	TestEventTemplateTestLimits pqtype.NullRawMessage
}

func (q *Queries) InsertTestResult(ctx context.Context, arg InsertTestResultParams) error {
	_, err := q.exec(ctx, q.insertTestResultStmt, insertTestResult,
		arg.ID,
		arg.UserID,
		arg.TypeID,
		arg.TypeType,
		arg.TypeResultType,
		arg.TypeName,
		arg.Timestamp,
		arg.Name,
		arg.Comment,
		arg.Data,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.TestEventID,
		arg.TestEventName,
		arg.TestEventDate,
		arg.TestEventTemplateTestID,
		arg.TestEventTemplateTestName,
		arg.TestEventTemplateTestLimits,
	)
	return err
}

const logDeletedUser = `-- name: LogDeletedUser :exec
INSERT INTO deleted_users_log (user_id, sportti_id)
SELECT users.id, users.sportti_id 
FROM users 
WHERE users.id = $1
`

func (q *Queries) LogDeletedUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.logDeletedUserStmt, logDeletedUser, id)
	return err
}

const upsertUser = `-- name: UpsertUser :exec
INSERT INTO users (
    id, sportti_id, profile_gender, profile_birthdate, profile_weight,
    profile_height, profile_resting_heart_rate, profile_maximum_heart_rate,
    profile_aerobic_threshold, profile_anaerobic_threshold, profile_vo2max
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8,
    $9, $10, $11
)
ON CONFLICT (id) DO UPDATE SET
    sportti_id = EXCLUDED.sportti_id,
    profile_gender = EXCLUDED.profile_gender,
    profile_birthdate = EXCLUDED.profile_birthdate,
    profile_weight = EXCLUDED.profile_weight,
    profile_height = EXCLUDED.profile_height,
    profile_resting_heart_rate = EXCLUDED.profile_resting_heart_rate,
    profile_maximum_heart_rate = EXCLUDED.profile_maximum_heart_rate,
    profile_aerobic_threshold = EXCLUDED.profile_aerobic_threshold,
    profile_anaerobic_threshold = EXCLUDED.profile_anaerobic_threshold,
    profile_vo2max = EXCLUDED.profile_vo2max
`

type UpsertUserParams struct {
	ID                        uuid.UUID
	SporttiID                 int32
	ProfileGender             sql.NullString
	ProfileBirthdate          sql.NullTime
	ProfileWeight             sql.NullFloat64
	ProfileHeight             sql.NullFloat64
	ProfileRestingHeartRate   sql.NullInt32
	ProfileMaximumHeartRate   sql.NullInt32
	ProfileAerobicThreshold   sql.NullInt32
	ProfileAnaerobicThreshold sql.NullInt32
	ProfileVo2max             sql.NullInt32
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.exec(ctx, q.upsertUserStmt, upsertUser,
		arg.ID,
		arg.SporttiID,
		arg.ProfileGender,
		arg.ProfileBirthdate,
		arg.ProfileWeight,
		arg.ProfileHeight,
		arg.ProfileRestingHeartRate,
		arg.ProfileMaximumHeartRate,
		arg.ProfileAerobicThreshold,
		arg.ProfileAnaerobicThreshold,
		arg.ProfileVo2max,
	)
	return err
}
