// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package utvsqlc

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"database/sql"
)

const addNotification = `-- name: AddNotification :one

INSERT INTO notifications(id, to_id, from_id, status, expires, notification)
VALUES(uuid_generate_v4(), $1, $2, $3, $4, $5)
RETURNING id
`

type AddNotificationParams struct {
	ToID         uuid.UUID
	FromID       uuid.UUID
	Status       int32
	Expires      int32
	Notification json.RawMessage
}

// notifications.py
func (q *Queries) AddNotification(ctx context.Context, arg AddNotificationParams) (uuid.UUID, error) {
	row := q.queryRow(ctx, q.addNotificationStmt, addNotification,
		arg.ToID,
		arg.FromID,
		arg.Status,
		arg.Expires,
		arg.Notification,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const addOrUpdateUser = `-- name: AddOrUpdateUser :exec
INSERT INTO user_data(user_id, data)
VALUES ($1, $2)
ON CONFLICT (user_id)
    DO UPDATE SET data = EXCLUDED.data
`

type AddOrUpdateUserParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
}

func (q *Queries) AddOrUpdateUser(ctx context.Context, arg AddOrUpdateUserParams) error {
	_, err := q.exec(ctx, q.addOrUpdateUserStmt, addOrUpdateUser, arg.UserID, arg.Data)
	return err
}

const addUser = `-- name: AddUser :exec


INSERT INTO user_data(user_id, data)
VALUES ($1, $2)
`

type AddUserParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
}

// Common sql queries
// user_db.py
func (q *Queries) AddUser(ctx context.Context, arg AddUserParams) error {
	_, err := q.exec(ctx, q.addUserStmt, addUser, arg.UserID, arg.Data)
	return err
}

const addUserToGroup = `-- name: AddUserToGroup :exec
INSERT INTO utv_group_members(group_id, user_id, added)
VALUES ($1, $2, $3)
`

type AddUserToGroupParams struct {
	GroupID uuid.NullUUID
	UserID  uuid.UUID
	Added   int32
}

func (q *Queries) AddUserToGroup(ctx context.Context, arg AddUserToGroupParams) error {
	_, err := q.exec(ctx, q.addUserToGroupStmt, addUserToGroup, arg.GroupID, arg.UserID, arg.Added)
	return err
}

const createGroup = `-- name: CreateGroup :exec
INSERT INTO utv_groups(id, group_name, created, active, deleted)
VALUES($1, $2, $3, $4, $5)
`

type CreateGroupParams struct {
	ID        uuid.UUID
	GroupName string
	Created   int32
	Active    int32
	Deleted   int32
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) error {
	_, err := q.exec(ctx, q.createGroupStmt, createGroup,
		arg.ID,
		arg.GroupName,
		arg.Created,
		arg.Active,
		arg.Deleted,
	)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM utv_groups
WHERE id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteGroupStmt, deleteGroup, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM user_data
WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteUserStmt, deleteUser, userID)
	return err
}

const getAllDataForDateOura = `-- name: GetAllDataForDateOura :one
SELECT data
FROM oura_data
WHERE user_id = $1
AND summary_date = $2
`

type GetAllDataForDateOuraParams struct {
	UserID      uuid.UUID
	Date 		time.Time
}

func (q *Queries) GetAllDataForDateOura(ctx context.Context, arg GetAllDataForDateOuraParams) (json.RawMessage, error) {
	row := q.queryRow(ctx, q.getAllDataForDateOuraStmt, getAllDataForDateOura, arg.UserID, arg.Date)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getAllDataForDatePolar = `-- name: GetAllDataForDatePolar :one
SELECT data
FROM polar_data
WHERE user_id = $1
AND summary_date = $2
`

type GetAllDataForDatePolarParams struct {
	UserID      uuid.UUID
	Date 		time.Time
}

func (q *Queries) GetAllDataForDatePolar(ctx context.Context, arg GetAllDataForDatePolarParams) (json.RawMessage, error) {
	row := q.queryRow(ctx, q.getAllDataForDatePolarStmt, getAllDataForDatePolar, arg.UserID, arg.Date)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getAllDataForDateSuunto = `-- name: GetAllDataForDateSuunto :one
SELECT data
FROM suunto_data
WHERE user_id = $1
AND summary_date = $2
`

type GetAllDataForDateSuuntoParams struct {
	UserID      uuid.UUID
	Date 		time.Time
}

func (q *Queries) GetAllDataForDateSuunto(ctx context.Context, arg GetAllDataForDateSuuntoParams) (json.RawMessage, error) {
	row := q.queryRow(ctx, q.getAllDataForDateSuuntoStmt, getAllDataForDateSuunto, arg.UserID, arg.Date)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getAllDataTypes = `-- name: GetAllDataTypes :many

SELECT data
FROM source_cache
WHERE ($1 IS NULL OR source = $1)
`

// api_db.py
func (q *Queries) GetAllDataTypes(ctx context.Context, dollar_1 interface{}) ([]json.RawMessage, error) {
	rows, err := q.query(ctx, q.getAllDataTypesStmt, getAllDataTypes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var data json.RawMessage
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}
		items = append(items, data)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppData = `-- name: GetAppData :many
SELECT data
FROM app_data
WHERE app_id = $1
AND field_name = $2
`

type GetAppDataParams struct {
	AppID     string
	FieldName string
}

func (q *Queries) GetAppData(ctx context.Context, arg GetAppDataParams) ([]json.RawMessage, error) {
	rows, err := q.query(ctx, q.getAppDataStmt, getAppData, arg.AppID, arg.FieldName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var data json.RawMessage
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}
		items = append(items, data)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataPointFromCoachtechData = `-- name: GetDataPointFromCoachtechData :many
WITH cte AS (
    SELECT coachtech_id
    FROM coachtech_ids
    WHERE user_id = $1
)
SELECT data
FROM coachtech_data
WHERE summary_date=$2
AND coachtech_id = (SELECT coachtech_id FROM cte)
`

type GetDataPointFromCoachtechDataParams struct {
	UserID      uuid.UUID
	SummaryDate time.Time
}

func (q *Queries) GetDataPointFromCoachtechData(ctx context.Context, arg GetDataPointFromCoachtechDataParams) ([]json.RawMessage, error) {
	rows, err := q.query(ctx, q.getDataPointFromCoachtechDataStmt, getDataPointFromCoachtechData, arg.UserID, arg.SummaryDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var data json.RawMessage
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}
		items = append(items, data)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatesFromCoachtechData = `-- name: GetDatesFromCoachtechData :many


WITH cte AS (
    SELECT coachtech_id
    FROM coachtech_ids
    WHERE user_id = $1
)
SELECT DISTINCT summary_date
FROM (
    SELECT summary_date
    FROM coachtech_data
    WHERE coachtech_id = (SELECT coachtech_id FROM cte)
    AND
    summary_date BETWEEN $2 AND $3
    AND
    data ->> 'testType' LIKE $4
) AS acceptables
ORDER BY summary_date DESC
`

type GetDatesFromCoachtechDataParams struct {
	UserID        uuid.UUID
	SummaryDate   time.Time
	SummaryDate_2 time.Time
	Data          json.RawMessage
}

// Wearable related functions
// api_db.py
func (q *Queries) GetDatesFromCoachtechData(ctx context.Context, arg GetDatesFromCoachtechDataParams) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getDatesFromCoachtechDataStmt, getDatesFromCoachtechData,
		arg.UserID,
		arg.SummaryDate,
		arg.SummaryDate_2,
		arg.Data,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var summary_date time.Time
		if err := rows.Scan(&summary_date); err != nil {
			return nil, err
		}
		items = append(items, summary_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatesFromOuraData = `-- name: GetDatesFromOuraData :many
SELECT DISTINCT summary_date
FROM oura_data
WHERE user_id = $1
AND ($2::date IS NULL OR summary_date >= $2)
AND ($3::date IS NULL OR summary_date <= $3)
ORDER BY summary_date DESC
`

type GetDatesFromOuraDataParams struct {
	UserID     uuid.UUID
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

func (q *Queries) GetDatesFromOuraData(ctx context.Context, arg GetDatesFromOuraDataParams) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getDatesFromOuraDataStmt, getDatesFromOuraData, arg.UserID, arg.AfterDate, arg.BeforeDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var summary_date time.Time
		if err := rows.Scan(&summary_date); err != nil {
			return nil, err
		}
		items = append(items, summary_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatesFromPolarData = `-- name: GetDatesFromPolarData :many
SELECT DISTINCT summary_date
FROM polar_data
WHERE user_id = $1
AND ($2::date IS NULL OR summary_date >= $2)
AND ($3::date IS NULL OR summary_date <= $3)
ORDER BY summary_date DESC
`

type GetDatesFromPolarDataParams struct {
	UserID     uuid.UUID
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

func (q *Queries) GetDatesFromPolarData(ctx context.Context, arg GetDatesFromPolarDataParams) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getDatesFromPolarDataStmt, getDatesFromPolarData, arg.UserID, arg.AfterDate, arg.BeforeDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var summary_date time.Time
		if err := rows.Scan(&summary_date); err != nil {
			return nil, err
		}
		items = append(items, summary_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatesFromSuuntoData = `-- name: GetDatesFromSuuntoData :many
SELECT DISTINCT summary_date
FROM suunto_data
WHERE user_id = $1
AND ($2::date IS NULL OR summary_date >= $2)
AND ($3::date IS NULL OR summary_date <= $3)
ORDER BY summary_date DESC
`

type GetDatesFromSuuntoDataParams struct {
	UserID     uuid.UUID
	AfterDate  sql.NullTime
	BeforeDate sql.NullTime
}

func (q *Queries) GetDatesFromSuuntoData(ctx context.Context, arg GetDatesFromSuuntoDataParams) ([]time.Time, error) {
	rows, err := q.query(ctx, q.getDatesFromSuuntoDataStmt, getDatesFromSuuntoData, arg.UserID, arg.AfterDate, arg.BeforeDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var summary_date time.Time
		if err := rows.Scan(&summary_date); err != nil {
			return nil, err
		}
		items = append(items, summary_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotification = `-- name: GetNotification :one
SELECT id, to_id, from_id, status, expires, notification
FROM notifications
WHERE id = $2 AND ($1 IS NULL OR expires >= $1)
`

type GetNotificationParams struct {
	Column1 interface{}
	ID      uuid.UUID
}

func (q *Queries) GetNotification(ctx context.Context, arg GetNotificationParams) (Notification, error) {
	row := q.queryRow(ctx, q.getNotificationStmt, getNotification, arg.Column1, arg.ID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.ToID,
		&i.FromID,
		&i.Status,
		&i.Expires,
		&i.Notification,
	)
	return i, err
}

const getResourceMetadata = `-- name: GetResourceMetadata :many
SELECT data
FROM resource_data
WHERE resource_id = $1
`

func (q *Queries) GetResourceMetadata(ctx context.Context, resourceID string) ([]json.RawMessage, error) {
	rows, err := q.query(ctx, q.getResourceMetadataStmt, getResourceMetadata, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var data json.RawMessage
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}
		items = append(items, data)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpecificDataForDateOura = `-- name: GetSpecificDataForDateOura :one
SELECT data->$3::text
FROM oura_data
WHERE user_id = $1
AND summary_date = $2
`

type GetSpecificDataForDateOuraParams struct {
	UserID      uuid.UUID
	Date 		time.Time
	Key     	*string
}

func (q *Queries) GetSpecificDataForDateOura(ctx context.Context, arg GetSpecificDataForDateOuraParams) (interface{}, error) {
	row := q.queryRow(ctx, q.getSpecificDataForDateOuraStmt, getSpecificDataForDateOura, arg.UserID, arg.Date, arg.Key)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getSpecificDataForDatePolar = `-- name: GetSpecificDataForDatePolar :one
SELECT data->$3::text
FROM polar_data
WHERE user_id = $1
AND summary_date = $2
`

type GetSpecificDataForDatePolarParams struct {
	UserID      uuid.UUID
	Date 		time.Time
	Key     	*string
}

func (q *Queries) GetSpecificDataForDatePolar(ctx context.Context, arg GetSpecificDataForDatePolarParams) (interface{}, error) {
	row := q.queryRow(ctx, q.getSpecificDataForDatePolarStmt, getSpecificDataForDatePolar, arg.UserID, arg.Date, arg.Key)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getSpecificDataForDateSuunto = `-- name: GetSpecificDataForDateSuunto :one
SELECT data->$3::text
FROM suunto_data
WHERE user_id = $1
AND summary_date = $2
`

type GetSpecificDataForDateSuuntoParams struct {
	UserID      uuid.UUID
	Date 		time.Time
	Key     	*string
}

func (q *Queries) GetSpecificDataForDateSuunto(ctx context.Context, arg GetSpecificDataForDateSuuntoParams) (interface{}, error) {
	row := q.queryRow(ctx, q.getSpecificDataForDateSuuntoStmt, getSpecificDataForDateSuunto, arg.UserID, arg.Date, arg.Key)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getTypesFromCoachtechData = `-- name: GetTypesFromCoachtechData :many
WITH cte AS (
    SELECT coachtech_id
    FROM coachtech_ids
    WHERE user_id = $1
)
SELECT DISTINCT data->>'testType', data->>'time', data->>'id'
FROM coachtech_data
WHERE summary_date = $2
  AND coachtech_id = (SELECT coachtech_id FROM cte)
  AND (
      ($3 IS NULL AND data->>'testType' IS NOT NULL) OR
      (data->>'testType' = $3)
  )
`

type GetTypesFromCoachtechDataParams struct {
	UserID      uuid.UUID
	SummaryDate time.Time
	Column3     interface{}
}

type GetTypesFromCoachtechDataRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
}

func (q *Queries) GetTypesFromCoachtechData(ctx context.Context, arg GetTypesFromCoachtechDataParams) ([]GetTypesFromCoachtechDataRow, error) {
	rows, err := q.query(ctx, q.getTypesFromCoachtechDataStmt, getTypesFromCoachtechData, arg.UserID, arg.SummaryDate, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTypesFromCoachtechDataRow
	for rows.Next() {
		var i GetTypesFromCoachtechDataRow
		if err := rows.Scan(&i.Column1, &i.Column2, &i.Column3); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesFromOuraData = `-- name: GetTypesFromOuraData :many
SELECT DISTINCT jsonb_object_keys(data)
FROM oura_data
WHERE user_id = $1
AND summary_date = $2
`

type GetTypesFromOuraDataParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetTypesFromOuraData(ctx context.Context, arg GetTypesFromOuraDataParams) ([]string, error) {
	rows, err := q.query(ctx, q.getTypesFromOuraDataStmt, getTypesFromOuraData, arg.UserID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var jsonb_object_keys string
		if err := rows.Scan(&jsonb_object_keys); err != nil {
			return nil, err
		}
		items = append(items, jsonb_object_keys)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesFromPolarData = `-- name: GetTypesFromPolarData :many
SELECT DISTINCT jsonb_object_keys(data)
FROM polar_data
WHERE user_id = $1
AND summary_date = $2
`

type GetTypesFromPolarDataParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetTypesFromPolarData(ctx context.Context, arg GetTypesFromPolarDataParams) ([]string, error) {
	rows, err := q.query(ctx, q.getTypesFromPolarDataStmt, getTypesFromPolarData, arg.UserID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var jsonb_object_keys string
		if err := rows.Scan(&jsonb_object_keys); err != nil {
			return nil, err
		}
		items = append(items, jsonb_object_keys)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesFromSuuntoData = `-- name: GetTypesFromSuuntoData :many
SELECT DISTINCT jsonb_object_keys(data)
FROM suunto_data
WHERE user_id = $1
AND summary_date = $2
`

type GetTypesFromSuuntoDataParams struct {
	UserID uuid.UUID
	Date   time.Time
}

func (q *Queries) GetTypesFromSuuntoData(ctx context.Context, arg GetTypesFromSuuntoDataParams) ([]string, error) {
	rows, err := q.query(ctx, q.getTypesFromSuuntoDataStmt, getTypesFromSuuntoData, arg.UserID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var jsonb_object_keys string
		if err := rows.Scan(&jsonb_object_keys); err != nil {
			return nil, err
		}
		items = append(items, jsonb_object_keys)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniqueCoachtechDataTypes = `-- name: GetUniqueCoachtechDataTypes :many
WITH cte AS (
    SELECT coachtech_id
    FROM coachtech_ids
    WHERE user_id = $1
)
SELECT DISTINCT data->>'testType'
FROM coachtech_data
WHERE coachtech_id = (SELECT coachtech_id FROM cte)
AND summary_date BETWEEN to_timestamp($2)::date AND to_timestamp($3)::date
`

type GetUniqueCoachtechDataTypesParams struct {
	UserID        uuid.UUID
	ToTimestamp   float64
	ToTimestamp_2 float64
}

func (q *Queries) GetUniqueCoachtechDataTypes(ctx context.Context, arg GetUniqueCoachtechDataTypesParams) ([]interface{}, error) {
	rows, err := q.query(ctx, q.getUniqueCoachtechDataTypesStmt, getUniqueCoachtechDataTypes, arg.UserID, arg.ToTimestamp, arg.ToTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var column_1 interface{}
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupMembers = `-- name: ListGroupMembers :many
SELECT user_id, added
FROM utv_group_members
WHERE group_id = $1
`

type ListGroupMembersRow struct {
	UserID uuid.UUID
	Added  int32
}

func (q *Queries) ListGroupMembers(ctx context.Context, groupID uuid.NullUUID) ([]ListGroupMembersRow, error) {
	rows, err := q.query(ctx, q.listGroupMembersStmt, listGroupMembers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGroupMembersRow
	for rows.Next() {
		var i ListGroupMembersRow
		if err := rows.Scan(&i.UserID, &i.Added); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroups = `-- name: ListGroups :many
SELECT id, group_name, created, active, deleted FROM utv_groups
`

func (q *Queries) ListGroups(ctx context.Context) ([]UtvGroup, error) {
	rows, err := q.query(ctx, q.listGroupsStmt, listGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UtvGroup
	for rows.Next() {
		var i UtvGroup
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.Created,
			&i.Active,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsForUser = `-- name: ListGroupsForUser :many
SELECT utv_groups.id, utv_groups.group_name, utv_groups.created, utv_groups.active, utv_groups.deleted FROM utv_groups, utv_group_members
WHERE utv_groups.id = utv_group_members.group_id
    AND utv_group_members.user_id = $1
`

func (q *Queries) ListGroupsForUser(ctx context.Context, userID uuid.UUID) ([]UtvGroup, error) {
	rows, err := q.query(ctx, q.listGroupsForUserStmt, listGroupsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UtvGroup
	for rows.Next() {
		var i UtvGroup
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.Created,
			&i.Active,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, to_id, from_id, status, expires, notification
FROM notifications
WHERE
    ($1 IS NULL OR to_id = $1) AND
    ($2 IS NULL OR from_id = $2) AND
    ($3 IS NULL OR expires >= $3) AND
    ($4 IS NULL OR $4)
`

type ListNotificationsParams struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
}

func (q *Queries) ListNotifications(ctx context.Context, arg ListNotificationsParams) ([]Notification, error) {
	rows, err := q.query(ctx, q.listNotificationsStmt, listNotifications,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.ToID,
			&i.FromID,
			&i.Status,
			&i.Expires,
			&i.Notification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromGroup = `-- name: RemoveUserFromGroup :exec
DELETE from utv_group_members
WHERE user_id = $1 AND group_id = $2
`

type RemoveUserFromGroupParams struct {
	UserID  uuid.UUID
	GroupID uuid.NullUUID
}

func (q *Queries) RemoveUserFromGroup(ctx context.Context, arg RemoveUserFromGroupParams) error {
	_, err := q.exec(ctx, q.removeUserFromGroupStmt, removeUserFromGroup, arg.UserID, arg.GroupID)
	return err
}

const retrieveUser = `-- name: RetrieveUser :one
SELECT data
FROM user_data
WHERE user_id = $1
`

func (q *Queries) RetrieveUser(ctx context.Context, userID uuid.UUID) (json.RawMessage, error) {
	row := q.queryRow(ctx, q.retrieveUserStmt, retrieveUser, userID)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const setAppData = `-- name: SetAppData :exec
INSERT INTO app_data(app_id, field_name, data)
VALUES($1, $2, $3)
ON CONFLICT(app_id, field_name)
DO UPDATE SET data = EXCLUDED.data
`

type SetAppDataParams struct {
	AppID     string
	FieldName string
	Data      json.RawMessage
}

func (q *Queries) SetAppData(ctx context.Context, arg SetAppDataParams) error {
	_, err := q.exec(ctx, q.setAppDataStmt, setAppData, arg.AppID, arg.FieldName, arg.Data)
	return err
}

const setNotificationStatus = `-- name: SetNotificationStatus :one
UPDATE notifications
SET status = $1 
WHERE id = $2
RETURNING status
`

type SetNotificationStatusParams struct {
	Status int32
	ID     uuid.UUID
}

func (q *Queries) SetNotificationStatus(ctx context.Context, arg SetNotificationStatusParams) (int32, error) {
	row := q.queryRow(ctx, q.setNotificationStatusStmt, setNotificationStatus, arg.Status, arg.ID)
	var status int32
	err := row.Scan(&status)
	return status, err
}

const setPersonalInformation = `-- name: SetPersonalInformation :exec
INSERT INTO user_data(user_id, data)
VALUES($1, $2)
ON CONFLICT(user_id)
DO UPDATE SET DATA = $3
`

type SetPersonalInformationParams struct {
	UserID uuid.UUID
	Data   json.RawMessage
	Data_2 json.RawMessage
}

func (q *Queries) SetPersonalInformation(ctx context.Context, arg SetPersonalInformationParams) error {
	_, err := q.exec(ctx, q.setPersonalInformationStmt, setPersonalInformation, arg.UserID, arg.Data, arg.Data_2)
	return err
}

const setResourceMetadata = `-- name: SetResourceMetadata :exec
INSERT INTO resource_data(resource_id, data)
VALUES($1, $2)
ON CONFLICT(resource_id)
DO UPDATE SET data = EXCLUDED.data
`

type SetResourceMetadataParams struct {
	ResourceID string
	Data       json.RawMessage
}

func (q *Queries) SetResourceMetadata(ctx context.Context, arg SetResourceMetadataParams) error {
	_, err := q.exec(ctx, q.setResourceMetadataStmt, setResourceMetadata, arg.ResourceID, arg.Data)
	return err
}

const toggleNotificationExpiration = `-- name: ToggleNotificationExpiration :one
UPDATE notifications
SET expires = -(SELECT expires FROM notifications WHERE notifications.id = $1)
WHERE notifications.id = $1
RETURNING expires
`

func (q *Queries) ToggleNotificationExpiration(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.queryRow(ctx, q.toggleNotificationExpirationStmt, toggleNotificationExpiration, id)
	var expires int32
	err := row.Scan(&expires)
	return expires, err
}
